# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Programmer_calc.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from ast import Num
import string
from turtle import Screen
from PyQt5 import QtCore, QtGui, QtWidgets
import math
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont
import re
from PyQt5.QtWidgets import QInputDialog


class Ui_Programmer_calc(object):
    def __init__(self):
        self.operations = []  # List to store operations
        self.operations2 = []  # List to store operations

    def applyStylesheet(self, Programmer_calc):
        stylesheet = """
        QListWidget{
            background-color: #2E2E2E;
            color: #ffffff;
            font: 14pt;
            border: 1px solid #555555;
            border-radius: 5px;
        }
        QMainWindow {
            background-color: #2E2E2E;
        }
        QWidget#centralwidget {
            background-color: #2E2E2E;
        }
        QLabel {
            color: #FFFFFF;
            font-family: 'Courier New', Courier, monospace; /* Monospaced font */
            font-size: 16pt; /* Increase font size */
            padding: 10px; /* Add padding */
            qproperty-alignment: 'AlignCenter'; /* Center align */
        }
        QComboBox, QTextEdit {
            background-color: #4E4E4E;
            color: #FFFFFF;
            border: 1px solid #555555;
            border-radius: 5px;
            padding: 5px;
        }
        QComboBox#shift_left, QComboBox#shift_right {
            background-color: #4E4E4E;
            font-size: 14pt;
            width: 50px;
            height: 50px;
            color: #FFFFFF;
            border: 1px solid #555555;
            border-radius: 5px;
            padding: 5px;
        }
        QComboBox QAbstractItemView {
            background-color: #4E4E4E;
            selection-background-color: #5E5E5E;
            color: #FFFFFF;
        }
        QLabel#label {
            font-family: 'Courier New', Courier, monospace; /* Monospaced font */
            font-size: 12pt;
            text-align: center;
        }
        QLabel#label_2 {
            font-size: 14pt;
            qproperty-alignment: 'AlignRight | AlignTrailing | AlignVCenter';
        }
        QPushButton#equal {
            background-color: #ff7300;
            width: 50px;
            height: 100%;
            color: #ffffff;
            border: 1px solid #555555;
            border-radius: 10px;
            padding: 10px;
        }
        QPushButton#equal:hover {
            background-color: #fc8e32;
        }
        QPushButton {
            background-color: #4E4E4E;
            font-size: 14pt;
            width: 50px;
            height: 50px;
            color: #FFFFFF;
            border: 1px solid #555555;
            border-radius: 10px;
            padding: 10px;
        }
        QLabel#h2_47, QLabel#n8_63, QLabel#nulla_15, QLabel#t6_31 {
            font-size: 16pt;
            font-family: 'Courier New', Courier, monospace; /* Monospaced font */
            padding: 10px; /* Add padding */
            qproperty-alignment: 'AlignCenter'; /* Center align */
        }
        QPushButton:hover {
            background-color: #5E5E5E;
        }
        QPushButton:pressed {
            background-color: #6E6E6E;
        }
        """
        Programmer_calc.setStyleSheet(stylesheet)

    def back_to_mainwindow(self, Egyenlet, MainWindow):
        Egyenlet.close()
        MainWindow.show()

    def set_to_null(self, list1, list2):
        for i in list1:
            i.setEnabled(True)

        self.pi.setEnabled(True)
        self.sqrt.setEnabled(True)
        self.dot.setEnabled(True)
        for i in list2:
            i.setEnabled(True)

    def handle_combobox_3_change(self):
        text = self.comboBox_3.currentText()

        hex_buttons = [
            self.A_hex,
            self.B_hex,
            self.C_hex,
            self.D_hex,
            self.E_hex,
            self.F_hex,
        ]
        numbers = [
            self.zero,
            self.one,
            self.two,
            self.three,
            self.four,
            self.five,
            self.six,
            self.seven,
            self.eight,
            self.nine,
        ]

        if text == "Bináris":
            self.set_to_null(hex_buttons, numbers)
            for i in hex_buttons:
                i.setEnabled(False)

            self.pi.setEnabled(False)
            self.dot.setEnabled(False)

            for i in range(2, len(numbers)):
                numbers[i].setEnabled(False)
        elif text == "Oktális":
            self.set_to_null(hex_buttons, numbers)
            self.pi.setEnabled(False)
            self.sqrt.setEnabled(False)
            for i in hex_buttons:
                i.setEnabled(False)

            for i in range(8, len(numbers)):
                numbers[i].setEnabled(False)
        elif text == "Decimális":
            self.set_to_null(hex_buttons, numbers)
            for i in hex_buttons:
                i.setEnabled(False)
        elif text == "Hexadecimális":
            self.set_to_null(hex_buttons, numbers)
            self.pi.setEnabled(False)
            self.sqrt.setEnabled(False)
            self.dot.setEnabled(False)

    def setupUi(self, Programmer_calc, MainWindow):
        self.applyStylesheet(Programmer_calc)
        Programmer_calc.setObjectName("Programmer_calc")
        Programmer_calc.resize(1080, 725)
        Programmer_calc.setMinimumSize(QtCore.QSize(1080, 725))
        Programmer_calc.setMaximumSize(QtCore.QSize(1080, 725))
        Programmer_calc.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)
        self.centralwidget = QtWidgets.QWidget(Programmer_calc)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayoutWidget_2 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_2.setGeometry(QtCore.QRect(10, 80, 1051, 61))
        self.verticalLayoutWidget_2.setObjectName("verticalLayoutWidget_2")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_2)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.Result = QtWidgets.QLineEdit(self.verticalLayoutWidget_2)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(24)
        self.Result.setFont(font)
        self.Result.setObjectName("Result")
        # self.Result.textChanged.connect(self.on_label_text_changed)
        self.verticalLayout_2.addWidget(self.Result)
        self.horizontalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(10, 0, 1051, 81))
        self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")

        self.operations_list = QtWidgets.QListWidget(self.centralwidget)
        self.operations_list.setGeometry(QtCore.QRect(10, 600, 1051, 100))  # Adjust size and position as needed
        self.operations_list.setObjectName("operations_list")
        self.horizontalLayout.addWidget(self.operations_list)
        self.operations_list.itemClicked.connect(self.on_item_clicked)

        self.operations_list2 = QtWidgets.QListWidget(self.centralwidget)
        self.operations_list2.setGeometry(QtCore.QRect(10, 600, 1051, 100))  # Adjust size and position as needed
        self.operations_list2.setObjectName("operations_list")
        self.horizontalLayout.addWidget(self.operations_list2)
        self.operations_list2.itemClicked.connect(self.on_item_clicked2)

        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(14)
        self.verticalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 230, 1051, 161))
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        font = QFont("Times New Roman", 14)
        self.n8_63 = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.n8_63.setAlignment(Qt.AlignCenter)
        self.n8_63.setObjectName("n8_63")
        self.verticalLayout.addWidget(self.n8_63)

        self.h2_47 = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.h2_47.setAlignment(Qt.AlignCenter)
        self.h2_47.setObjectName("h2_47")
        self.verticalLayout.addWidget(self.h2_47)

        self.t6_31 = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.t6_31.setAlignment(Qt.AlignCenter)
        self.t6_31.setObjectName("t6_31")
        self.verticalLayout.addWidget(self.t6_31)

        self.nulla_15 = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.nulla_15.setAlignment(Qt.AlignCenter)
        self.nulla_15.setObjectName("nulla_15")
        self.verticalLayout.addWidget(self.nulla_15)
        self.horizontalLayoutWidget_2 = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget_2.setGeometry(QtCore.QRect(10, 131 , 1051, 59))
        self.horizontalLayoutWidget_2.setObjectName("horizontalLayoutWidget_2")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget_2)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.comboBox_3 = QtWidgets.QComboBox(self.horizontalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.comboBox_3.setFont(font)
        self.comboBox_3.setObjectName("comboBox_3")
        self.comboBox_3.addItem("")
        self.comboBox_3.addItem("")
        self.comboBox_3.addItem("")
        self.comboBox_3.addItem("")
        self.horizontalLayout_2.addWidget(self.comboBox_3)
        spacerItem1 = QtWidgets.QSpacerItem(
            700, 0, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum
        )
        self.horizontalLayout_2.addItem(spacerItem1)
        self.label_2 = QtWidgets.QLabel(self.horizontalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.label_2.setFont(font)
        self.label_2.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_2.addWidget(self.label_2)
        self.horizontalLayoutWidget_3 = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget_3.setGeometry(QtCore.QRect(10, 390, 1051, 311))
        self.horizontalLayoutWidget_3.setObjectName("horizontalLayoutWidget_3")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget_3)
        self.horizontalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.gridLayout_for_numbers = QtWidgets.QGridLayout()
        self.gridLayout_for_numbers.setObjectName("gridLayout_for_numbers")
        self.bel_zj = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("("),
        )
        self.bel_zj.setObjectName("bel_zj")
        self.gridLayout_for_numbers.addWidget(self.bel_zj, 0, 1, 1, 1)
        self.eight = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("8"),
        )
        self.eight.setObjectName("eight")
        self.gridLayout_for_numbers.addWidget(self.eight, 3, 0, 1, 1)
        self.D_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("D"),
        )
        self.D_hex.setObjectName("D_hex")
        self.gridLayout_for_numbers.addWidget(self.D_hex, 1, 1, 1, 1)
        self.C_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("C"),
        )
        self.C_hex.setObjectName("C_hex")
        self.gridLayout_for_numbers.addWidget(self.C_hex, 1, 0, 1, 1)
        self.three = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("3"),
        )
        self.three.setObjectName("three")
        self.gridLayout_for_numbers.addWidget(self.three, 5, 3, 1, 1)
        self.minus = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("-"),
        )
        self.minus.setObjectName("minus")
        self.gridLayout_for_numbers.addWidget(self.minus, 4, 4, 1, 1)
        self.dot = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("."),
        )
        self.dot.setObjectName("dot")
        self.gridLayout_for_numbers.addWidget(self.dot, 3, 5, 1, 1)
        self.B_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("B"),
        )
        self.B_hex.setObjectName("B_hex")
        self.gridLayout_for_numbers.addWidget(self.B_hex, 3, 3, 1, 1)
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.clear = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("DEL"),
        )
        self.clear.setObjectName("clear")
        self.verticalLayout_4.addWidget(self.clear)
        self.gridLayout_for_numbers.addLayout(self.verticalLayout_4, 0, 0, 1, 1)
        self.four = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("4"),
        )
        self.four.setObjectName("four")
        self.gridLayout_for_numbers.addWidget(self.four, 4, 0, 1, 1)
        self.jobb_zj = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it(")"),
        )
        self.jobb_zj.setObjectName("jobb_zj")
        self.gridLayout_for_numbers.addWidget(self.jobb_zj, 0, 2, 1, 1)
        self.one = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("1"),
        )
        self.one.setObjectName("one")
        self.gridLayout_for_numbers.addWidget(self.one, 5, 1, 1, 1)
        self.nine = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("9"),
        )
        self.nine.setObjectName("nine")
        self.gridLayout_for_numbers.addWidget(self.nine, 3, 1, 1, 1)
        self.mod = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("%"),
        )
        self.mod.setObjectName("mod")
        self.gridLayout_for_numbers.addWidget(self.mod, 0, 3, 1, 1)
        self.A_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("A"),
        )
        self.A_hex.setObjectName("A_hex")
        self.gridLayout_for_numbers.addWidget(self.A_hex, 3, 2, 1, 1)
        self.zero = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("0"),
        )
        self.zero.setObjectName("zero")
        self.gridLayout_for_numbers.addWidget(self.zero, 5, 0, 1, 1)
        self.two = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("2"),
        )
        self.two.setObjectName("two")
        self.gridLayout_for_numbers.addWidget(self.two, 5, 2, 1, 1)
        self.six = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("6"),
        )
        self.six.setObjectName("six")
        self.gridLayout_for_numbers.addWidget(self.six, 4, 2, 1, 1)
        self.F_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("F"),
        )
        self.F_hex.setObjectName("F_hex")
        self.gridLayout_for_numbers.addWidget(self.F_hex, 1, 3, 1, 1)
        self.plusz = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("+"),
        )
        self.plusz.setObjectName("plusz")
        self.gridLayout_for_numbers.addWidget(self.plusz, 5, 4, 1, 1)
        self.seven = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("7"),
        )
        self.seven.setObjectName("seven")
        self.gridLayout_for_numbers.addWidget(self.seven, 4, 3, 1, 1)
        self.equal = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.evaluate_expression(),
        )
        self.equal.setObjectName("equal")
        self.gridLayout_for_numbers.addWidget(self.equal, 4, 5, 2, 1)
        self.five = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("5"),
        )
        self.five.setObjectName("five")
        self.gridLayout_for_numbers.addWidget(self.five, 4, 1, 1, 1)
        self.divide = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("/"),
        )
        self.divide.setObjectName("divide")
        self.gridLayout_for_numbers.addWidget(self.divide, 1, 4, 1, 1)
        self.szorzas = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("*"),
        )
        self.szorzas.setObjectName("szorzas")
        self.gridLayout_for_numbers.addWidget(self.szorzas, 3, 4, 1, 1)
        self.sqrt = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("SQRT"),
        )
        self.sqrt.setObjectName("sqrt")
        self.gridLayout_for_numbers.addWidget(self.sqrt, 1, 5, 1, 1)
        self.E_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("E"),
        )
        self.E_hex.setObjectName("E_hex")
        self.gridLayout_for_numbers.addWidget(self.E_hex, 1, 2, 1, 1)
        self.pi = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("3.14"),
        )
        self.pi.setObjectName("pi")
        self.gridLayout_for_numbers.addWidget(self.pi, 0, 4, 1, 2)
        self.horizontalLayout_3.addLayout(self.gridLayout_for_numbers)
        self.gridLayout_for_special_buttons = QtWidgets.QGridLayout()
        self.gridLayout_for_special_buttons.setObjectName(
            "gridLayout_for_special_buttons"
        )
        self.fakt = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("!"),
        )
        self.fakt.setObjectName("fakt")
        self.gridLayout_for_special_buttons.addWidget(self.fakt, 3, 0, 1, 2)
        self.XOR = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it(" XOR ")
        )
        self.XOR.setObjectName("XOR")
        self.gridLayout_for_special_buttons.addWidget(self.XOR, 0, 4, 1, 1)

        self.abs = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("|"),
        )
        self.abs.setObjectName("abs")
        self.gridLayout_for_special_buttons.addWidget(self.abs, 3, 2, 1, 1)
        self.NOT = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it(" NOT "),
        )
        self.NOT.setObjectName("NOT")
        self.gridLayout_for_special_buttons.addWidget(self.NOT, 1, 2, 1, 1)
        self.log = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("log"),
        )
        self.log.setObjectName("log")
        self.gridLayout_for_special_buttons.addWidget(self.log, 2, 4, 1, 1)
        self.x_xx_y = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("**"),
        )
        self.x_xx_y.setObjectName("x_xx_y")
        self.gridLayout_for_special_buttons.addWidget(self.x_xx_y, 2, 0, 1, 1)

        self.ones = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("ones "),
        )
        self.ones.setObjectName("ones")
        self.gridLayout_for_special_buttons.addWidget(self.ones, 1, 0, 1, 1)
        self.int_2 = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("int "),
        )
        self.int_2.setObjectName("int_2")
        self.gridLayout_for_special_buttons.addWidget(self.int_2, 2, 2, 1, 1)
        self.x_xx_1 = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("**-1"),
        )
        self.x_xx_1.setObjectName("x_xx_1")
        self.gridLayout_for_special_buttons.addWidget(self.x_xx_1, 2, 1, 1, 1)
        self.twos = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("twos "),
        )
        self.twos.setObjectName("twos")
        self.gridLayout_for_special_buttons.addWidget(self.twos, 1, 1, 1, 1)
        self.AND = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it(" AND ")
        )
        self.AND.setObjectName("AND")
        self.gridLayout_for_special_buttons.addWidget(self.AND, 1, 3, 1, 1)
        self.log2 = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("log2"),
        )
        self.log2.setObjectName("log2")
        self.gridLayout_for_special_buttons.addWidget(self.log2, 2, 3, 1, 1)
        self.OR = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it(" OR ")
        )
        self.OR.setObjectName("OR")
        self.gridLayout_for_special_buttons.addWidget(self.OR, 1, 4, 1, 1)
        self.shift_left = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it("<<")
        )
        self.shift_left.setObjectName("shift_left")
        self.gridLayout_for_special_buttons.addWidget(self.shift_left, 0, 0, 1, 2)
        self.shift_right = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it(">>")
        )
        self.shift_right.setObjectName("shift_right")
        self.gridLayout_for_special_buttons.addWidget(self.shift_right, 0, 2, 1, 2)
        self.aaaa = QtWidgets.QPushButton(self.horizontalLayoutWidget_3)
        self.aaaa.setObjectName("aaaa")
        self.aaaa.clicked.connect(self.show_dialog)
        self.gridLayout_for_special_buttons.addWidget(self.aaaa, 3, 3, 1, 2)
        self.fact = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("FACT"),
        )
        self.fact.setObjectName("fact")
        self.gridLayout_for_special_buttons.addWidget(self.fact, 4, 0, 1, 5)
        self.horizontalLayout_3.addLayout(self.gridLayout_for_special_buttons)
        Programmer_calc.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(Programmer_calc)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1083, 21))
        self.menubar.setObjectName("menubar")
        Programmer_calc.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(Programmer_calc)
        self.statusbar.setObjectName("statusbar")
        Programmer_calc.setStatusBar(self.statusbar)

        self.comboBox_3.currentTextChanged.connect(self.handle_combobox_3_change)
        self.retranslateUi(Programmer_calc)
        QtCore.QMetaObject.connectSlotsByName(Programmer_calc)

    def show_dialog(self):
        text, ok = QInputDialog.getText(
            self.centralwidget, "Input Dialog", "Enter a character:"
        )
        if ok and text:
            ascii_value = ord(text)
            current_mode = self.comboBox_3.currentText()

            if current_mode == "Decimális":
                converted_value = str(ascii_value)
            elif current_mode == "Hexadecimális":
                converted_value = hex(ascii_value)[
                    2:
                ].upper()  # Convert to hex and remove '0x' prefix
            elif current_mode == "Bináris":
                converted_value = bin(ascii_value)[
                    2:
                ]  # Convert to binary and remove '0b' prefix
            elif current_mode == "Oktális":
                converted_value = oct(ascii_value)[
                    2:
                ]  # Convert to octal and remove '0o' prefix

            self.Result.setText(self.Result.text() + converted_value)

    def press_it(self, pressed):
        if pressed == "DEL":
            self.Result.setText("0")
        if self.Result.text() == "ERROR":
            self.Result.setText("")
            # Check to see if it starts with 0 and delete the zero
        if self.Result.text() == "0":
            self.Result.setText("")
        # concatenate the pressed button with what was there already
        else:
            self.Result.setText(f"{self.Result.text()}{pressed}")

    def is_prime(self, n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    def factorize(self, n):
        if self.is_prime(n):
            return [n]

        factors = []
        divisor = 2
        while n >= 2:
            if n % divisor == 0:
                factors.append(divisor)
                n //= divisor
            else:
                divisor += 1
                while not self.is_prime(divisor):
                    divisor += 1
        return factors

    def convert_and_factorize(self, input_num):

        # Determine the base of the input number
        if input_num.startswith("0b"):
            base = 2
        elif input_num.startswith("0x"):
            base = 16
        elif input_num.startswith("0o"):
            base = 8
        else:
            base = 10

        # Convert the number to decimal
        decimal_number = int(input_num, base)

        # Factorize the decimal number
        factors = self.factorize(decimal_number)

        # Convert factors back to the original base
        if base == 2:
            factors_str = "*".join(bin(f)[2:] for f in factors)
        elif base == 16:
            factors_str = "*".join(hex(f)[2:] for f in factors)
        elif base == 8:
            factors_str = "*".join(oct(f)[2:] for f in factors)
        else:
            factors_str = "*".join(map(str, factors))

        return factors_str

    def factorial(self, num_str, num_system):
        # Determine the base and convert to decimal
        if num_system == "binary":
            base = 2
        elif num_system == "octal":
            base = 8
        elif num_system == "hexadecimal":
            base = 16
        elif num_system == "decimal":
            base = 10
        else:
            raise ValueError("Invalid number system")

        # Convert to decimal float
        decimal_num = float(int(num_str, base)) if base != 10 else float(num_str)

        # Calculate factorial
        def calc_factorial(n):
            if n < 0:
                raise ValueError("Factorial is not defined for negative numbers")
            elif n == 0 or n == 1:
                return 1
            elif n != int(n):
                return math.gamma(n + 1)  # Gamma(n+1) is the factorial for non-integers
            else:
                return math.factorial(int(n))  # Use math.factorial for integer values

        factorial_result = calc_factorial(decimal_num)

        # Convert the result back to the original format
        if base == 2:
            result = bin(int(factorial_result))
        elif base == 8:
            result = oct(int(factorial_result))
        elif base == 16:
            result = hex(int(factorial_result))
        else:
            result = str(factorial_result)

        return result

    def only_one_fact(self, string):
        cnt = 0
        for i in string:
            if i == "!":
                cnt += 1

        return cnt

    def evaluate_expression(self):
        screen = self.Result.text()
        operation = screen  # Store the current operation

        if self.comboBox_3.currentText() == "Decimális":
            if "int" in screen:
                try:
                    answer = self.round_down_number(screen.split("int")[1], "decimal")
                    print("#LOG: kerekítés egészre")
                except:
                    answer = None
                    self.Result.setText("Helytelen kerekítés egészre!")
            elif "ones" in screen:
                try:
                    answer = self.ones_complement(screen.split("ones")[1], 10)
                    print("#LOG: egyes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen egyes komlemens!")
            elif (
                not self.contain_logical(screen)
                and self.contains_sqrt(screen)
                and self.only_one_fact(screen) == 0
            ):
                try:
                    answer = self.sqrt_func(screen, "decimal")
                    print("#LOG: csak gyökvonás")
                except:
                    answer = None
                    self.Result.setText("Helytelen gyökvonás!")
            elif "<<" in screen or ">>" in screen:
                print("#LOG: shiftelés")
                try:
                    if "<<" in screen:
                        num = screen.split("<<")[0]
                        cnt = screen.split("<<")[1]
                        answer = self.shift_left_func(cnt, num)
                    if ">>" in screen:
                        num = screen.split(">>")[0]
                        cnt = screen.split(">>")[1]
                        answer = self.shift_right_func(cnt, num)
                except:
                    answer = None
                    self.Result.setText("Helytelen shiftelés!")
            elif (
                self.contain_arithmetic(screen)
                and not self.contain_logical(screen)
                and self.only_one_fact(screen) == 0
            ):
                try:
                    answer = eval(screen)
                    print("#LOG: csak aritmetikai")
                except:
                    answer = None
                    self.Result.setText("Helytelen aritmetikai müvelet!")
            elif "FACT" in screen:
                try:
                    print("#LOG: FACT")
                    answer = self.convert_and_factorize(screen.split("FACT")[1])
                except:
                    answer = None
                    self.Result.setText("Helytelen factorizáció!")
            elif self.only_one_fact(screen) == 1 and "!" in screen:
                try:
                    print("#LOG: factorial")
                    answer = self.factorial(screen.split("!")[0], "decimal")
                except:
                    answer = None
                    self.Result.setText("Helytelen faktoriális!")
            elif not self.contain_arithmetic(screen) and self.contain_logical(screen):
                try:
                    print("#LOG: csak logikai")
                    answer = self.logical_ops(screen)
                except:
                    answer = None
                    self.Result.setText("Helytelen logikai!")
            else:
                try:
                    print("#LOG: egyébként")
                    answer = eval(screen)
                except:
                    self.Result.setText("ERROR!")
                    answer = None

            if answer is not None:
                self.Result.setText(str(answer))

                self.operations.append(f"{operation}")
                self.update_operations_display()

                self.operations2.append(f"{answer}")
                self.update_operations_display2()

            if type(answer) is int:
                binary_segments = self.decimal_to_decimal_64bit_segments(answer)
                self.n8_63.setText(f"64 {self.format_binary(binary_segments[0])} 48")
                self.h2_47.setText(f"47 {self.format_binary(binary_segments[1])} 32")
                self.t6_31.setText(f"31 {self.format_binary(binary_segments[2])} 16")
                self.nulla_15.setText(f"15 {self.format_binary(binary_segments[3])}  0")
            else:
                self.n8_63.setText(f"")
                self.h2_47.setText(f"")
                self.t6_31.setText(f"")
                self.nulla_15.setText(f"")
        elif self.comboBox_3.currentText() == "Oktális":
            answer = 0
            if "int" in screen:
                try:
                    answer = self.round_down_number(screen.split("int")[1], "octal")
                    print("#LOG: kerekítés egészre")
                except:
                    answer = None
                    self.Result.setText("Helytelen kerekítés egészre!")
            elif "ones" in screen:
                try:
                    number = screen.split(" ")[1]
                    print(number)
                    answer = self.ones_complement(number, 8)
                    print("#LOG: egyes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen egyes komlemens!")
            elif self.contain_arithmetic(screen) and not self.contain_logical(screen):
                answer = self.evaluate_octal_expression(screen)
            elif not self.contain_arithmetic(screen) and self.contain_logical(screen):
                answer = self.evaluate_octal_logical_expression(screen)
            elif "FACT" in screen:
                answer = self.convert_and_factorize("0o" + screen.split("FACT")[1])
            else:
                answer = eval(screen)
            self.Result.setText(str(answer))
            try:
                octal_segments = self.octal_octal_to_64bit_segments(answer)
                self.n8_63.setText(f"64 {self.format_binary(octal_segments[1])} 48")
                self.h2_47.setText(f"47 {self.format_binary(octal_segments[2])} 32")
                self.t6_31.setText(f"31 {self.format_binary(octal_segments[2])} 16")
                self.nulla_15.setText(f"15 {self.format_binary(octal_segments[3])} 0")
            except:
                self.n8_63.setText(f"")
                self.h2_47.setText(f"")
                self.t6_31.setText(f"")
                self.nulla_15.setText(f"")
        elif self.comboBox_3.currentText() == "Bináris":

            answer = 0
            if "int" in screen:
                try:
                    answer = self.round_down_number(screen.split("int")[1], "binary")
                    print("#LOG: kerekítés egészre")
                except:
                    answer = None
                    self.Result.setText("Helytelen kerekítés egészre!")
            elif "ones" in screen:
                try:
                    answer = self.ones_complement(screen.split("ones")[1], 2)
                    print("#LOG: egyes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen egyes komlemens!")
            elif not self.contain_logical(screen) and self.contains_sqrt(screen):
                answer = self.sqrt_func(screen, "binary")
            elif self.contain_arithmetic(screen) and not self.contain_logical(screen):
                answer = self.evaluate_binary_expression(screen)
            elif "FACT" in screen:
                answer = self.convert_and_factorize("0b" + screen.split("FACT")[1])
            elif not self.contain_arithmetic(screen) and self.contain_logical(screen):
                answer = self.evaluate_binary_logical_expression(screen)
            else:
                answer = eval(screen)
            self.Result.setText(str(answer))
            try:
                binary_segments = self.binary_tobinary_64bit_segments(answer)
                self.n8_63.setText(f"64 {self.format_binary(binary_segments[0])} 48")
                self.h2_47.setText(f"47 {self.format_binary(binary_segments[1])} 32")
                self.t6_31.setText(f"31 {self.format_binary(binary_segments[2])} 16")
                self.nulla_15.setText(f"15 {self.format_binary(binary_segments[3])} 0")
            except:
                self.n8_63.setText(f"")
                self.h2_47.setText(f"")
                self.t6_31.setText(f"")
                self.nulla_15.setText(f"")
        elif self.comboBox_3.currentText() == "Hexadecimális":

            answer = 0
            if "twos" in screen:
                try:
                    number = screen.split("twos ")[1]
                    print(f"'{number}'")
                    answer = self.twos_complement(number, 16)
                    print(answer)
                    print("#LOG: kettes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen kettes komlemens!")
            elif "int" in screen:
                try:
                    answer = self.round_down_number(screen.split("int")[1], "hex")
                    print("#LOG: kerekítés egészre")
                except:
                    answer = None
                    self.Result.setText("Helytelen kerekítés egészre!")
            elif "ones" in screen:
                try:
                    number = screen.split(" ")[1]
                    print(number)
                    answer = self.ones_complement(number, 16)
                    print("#LOG: egyes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen egyes komlemens!")
            elif self.contain_arithmetic(screen) and not self.contain_logical(screen):
                answer = self.evaluate_hex_expression(screen)
            elif not self.contain_arithmetic(screen) and self.contain_logical(screen):
                answer = self.logical_ops(screen)
            elif "FACT" in screen:
                answer = self.convert_and_factorize("0x" + screen.split("FACT")[1])
            elif "<<" in screen or ">>" in screen:
                if "<<" in screen:
                    num = screen.split("<<")[0]
                    cnt = screen.split("<<")[1]
                    answer = self.hex_shift_left_func(cnt, num)
                if ">>" in screen:
                    num = screen.split(">>")[0]
                    cnt = screen.split(">>")[1]
                    answer = self.hex_shift_right_func(cnt, num)
            else:
                answer = screen
            
            if answer is not None:
                self.Result.setText(str(answer))
                # Append the operation and result to the operations list
                self.operations.append(f"{operation} = {answer}")
                # Update the display of operations
                self.update_operations_display()

            self.Result.setText(str(answer))
            if isinstance(answer, str):
                binary_segments = self.hexidecimal_to_hexidecimal_64bit_segments(
                    str(answer)
                )
                self.n8_63.setText(f"64 {self.format_binary(binary_segments[0])} 48")
                self.h2_47.setText(f"47 {self.format_binary(binary_segments[1])} 32")
                self.t6_31.setText(f"31 {self.format_binary(binary_segments[2])} 16")
                self.nulla_15.setText(f"15 {self.format_binary(binary_segments[3])}  0")
            else:
                self.n8_63.setText(f"")
                self.h2_47.setText(f"")
                self.t6_31.setText(f"")
                self.nulla_15.setText(f"")

    def twos_complement(self, number: str, base: int) -> str:

        # Convert the input number to an integer
        if base == 2:
            int_number = int(number, 2)
        elif base == 8:
            int_number = int(number, 8)
        elif base == 10:
            int_number = int(number)
        elif base == 16:
            int_number = int(number, 16)
        else:
            raise ValueError("Base must be one of 2, 8, 10, or 16")

        # Calculate one's complement by flipping the bits
        max_num = (1 << 64) - 1
        ones_complement_int = int_number ^ max_num

        # Calculate two's complement by adding one to the one's complement result
        twos_complement_int = ones_complement_int + 1

        # Convert back to the original base
        if base == 2:
            result = bin(twos_complement_int)[2:].zfill(
                64
            )  # Remove the '0b' prefix and pad with zeros
        elif base == 8:
            result = oct(twos_complement_int)[2:].zfill(
                64 // 3
            )  # Remove the '0o' prefix and pad with zeros
        elif base == 10:
            result = twos_complement_int
        elif base == 16:
            result = (
                hex(twos_complement_int)[2:].upper().zfill(64 // 4)
            )  # Remove the '0x' prefix and pad with zeros

        return result

    def ones_complement(self, number: str, base: int) -> str:
        # Convert the input number to an integer
        if base == 2:
            int_number = int(number, 2)
        elif base == 8:
            int_number = int(number, 8)
        elif base == 10:
            int_number = int(number)
        elif base == 16:
            int_number = int(number, 16)
        else:
            raise ValueError("Base must be one of 2, 8, 10, or 16")

        # Calculate one's complement by flipping the bits
        max_num = (1 << 64) - 1
        ones_complement_int = int_number ^ max_num

        # Convert back to the original base
        if base == 2:
            result = bin(ones_complement_int)[2:].zfill(
                64
            )  # Remove the '0b' prefix and pad with zeros
        elif base == 8:
            result = oct(ones_complement_int)[2:].zfill(
                64 // 3
            )  # Remove the '0o' prefix and pad with zeros
        elif base == 10:
            result = ones_complement_int
        elif base == 16:
            result = (
                hex(ones_complement_int)[2:].upper().zfill(64 // 4)
            )  # Remove the '0x' prefix and pad with zeros

        return result

    def round_down_number(self, number: str, mode: str) -> str:
        def convert_to_decimal(number: str, base: int) -> float:
            if "." in number:
                integer_part, fractional_part = number.split(".")
                integer_value = int(integer_part, base)
                fractional_value = sum(
                    int(digit, base) * (base**-i)
                    for i, digit in enumerate(fractional_part, 1)
                )
                return integer_value + fractional_value
            else:
                return int(number, base)

        def convert_from_decimal(number: int, base: int) -> str:
            if base == 2:
                return bin(number)[2:]
            elif base == 8:
                return oct(number)[2:]
            elif base == 16:
                return hex(number)[2:].upper()
            else:
                return str(number)

        if mode == "binary":
            num = convert_to_decimal(number, 2)
            rounded_num = math.floor(num)
            return convert_from_decimal(rounded_num, 2)
        elif mode == "decimal":
            num = float(number)
            rounded_num = math.floor(num)
            return str(rounded_num)
        elif mode == "octal":
            num = convert_to_decimal(number, 8)
            rounded_num = math.floor(num)
            return convert_from_decimal(rounded_num, 8)
        elif mode == "hex":
            num = convert_to_decimal(number, 16)
            rounded_num = math.floor(num)
            return convert_from_decimal(rounded_num, 16)
        else:
            raise ValueError(
                "Invalid mode. Choose from 'binary', 'decimal', 'octal', or 'hex'."
            )

    def shift_left_func(self, num: str, number: str):
        # Ensure the input number is an integer
        if not number.isdigit():
            return f"{number}: a megadott érték nem egész szám"

        # Calculate the new number by shifting to the left
        new_number = int(number) << int(num)

        # Return the new number as a string
        return new_number

    def shift_right_func(self, num: str, number: str):
        # Ensure the input number is an integer
        if not number.isdigit():
            return f"{number}: a megadott érték nem egész szám"

        # Calculate the new number by shifting to the right
        new_number = int(number) >> int(num)

        # Return the new number as a string
        return new_number

    def is_valid_hex(self, number: str) -> bool:
        try:
            int(number, 16)
            return True
        except ValueError:
            return False

    def hex_shift_left_func(self, num: str, hex_number: str) -> str:
        # Ensure the input hex number is valid
        if not self.is_valid_hex(hex_number):
            raise ValueError("The provided number is not a valid hexadecimal")

        # Calculate the new number by shifting to the left
        new_number = int(hex_number, 16) << int(num)

        # Return the new number as a hexadecimal string
        return int(str(hex(new_number))[2:])

    def hex_shift_right_func(self, num: str, hex_number: str) -> str:
        # Ensure the input hex number is valid
        if not self.is_valid_hex(hex_number):
            raise ValueError("The provided number is not a valid hexadecimal")

        # Calculate the new number by shifting to the right
        new_number = int(hex_number, 16) >> int(num)

        # Return the new number as a hexadecimal string
        return int(str(hex(new_number))[2:])

    def contains_sqrt(self, string):
        for i in string:
            if "SQRT" in string:
                return True
        return False

    def contain_arithmetic(self, string):
        contains_arithmetic = False
        arithmetic_exp = ["*", "/", "%", "-", "+"]

        for op in arithmetic_exp:
            if op in string:
                contains_arithmetic = True
                break

        return contains_arithmetic

    def contain_logical(self, string):
        contains_logical = False
        logical_exp = ["AND", "OR", "XOR", "NOT"]

        for op in logical_exp:
            if op in string:
                contains_logical = True
                break

        return contains_logical

    def format_binary(self, binary_string):
        # Insert a space every four characters
        formatted_string = " ".join(
            binary_string[i : i + 4] for i in range(0, len(binary_string), 4)
        )
        return formatted_string

    def decimal_to_decimal_64bit_segments(self, number):
        if not isinstance(number, int):
            return "Error: Input must be an integer."

        if number == 0:
            return [
                "0000000000000000",
                "0000000000000000",
                "0000000000000000",
                "0000000000000000",
            ]  # Special case for zero

        binary_result = ""
        while number > 0:
            binary_result = str(number % 2) + binary_result
            number //= 2

        # Pad with leading zeros to make it 64 bits
        binary_result = binary_result.zfill(64)

        # Split into 16-bit segments
        segments = [binary_result[i : i + 16] for i in range(0, 64, 16)]

        return segments

    def octal_octal_to_64bit_segments(self, octal_number):
        # Convert octal to binary
        binary_string = bin(int(str(octal_number), 8))[2:]

        # Pad with leading zeros to make it 64 bits
        padded_binary = binary_string.zfill(64)

        # Split into 16-bit chunks
        chunks = [padded_binary[i : i + 16] for i in range(0, 64, 16)]

        return chunks

    def evaluate_octal_expression(self, expression):
        # Define a helper function to convert octal to decimal
        def oct_to_dec(oct_str):
            return int(oct_str, 8)

        # Define a helper function to convert decimal to octal
        def dec_to_oct(dec_int):
            return oct(dec_int)[2:]

        # Replace octal numbers with their decimal equivalents in the expression
        def replace_octal_with_decimal(expr):
            octal_numbers = re.findall(r"[0-7]+", expr)
            for oct_num in octal_numbers:
                expr = expr.replace(oct_num, str(oct_to_dec(oct_num)), 1)
            return expr

        # Replace octal numbers with decimal equivalents
        decimal_expression = replace_octal_with_decimal(expression)

        # Evaluate the decimal expression
        try:
            result = eval(decimal_expression)
        except ZeroDivisionError:
            return "Error: Division by zero"
        except Exception as e:
            return f"Error: {e}"

        # Convert the result back to octal
        return dec_to_oct(result)

    def evaluate_octal_logical_expression(self, expression):
        # Define a helper function to convert octal to decimal
        def oct_to_dec(oct_str):
            return int(oct_str, 8)

        # Define a helper function to convert decimal to octal
        def dec_to_oct(dec_int):
            return oct(dec_int)[2:]

        # Replace octal numbers with their decimal equivalents in the expression
        def replace_octal_with_decimal(expr):
            octal_numbers = re.findall(r"\b[0-7]+\b", expr)
            for oct_num in octal_numbers:
                expr = expr.replace(oct_num, str(oct_to_dec(oct_num)), 1)
            return expr

        # Define the logical operators and their corresponding lambda functions
        logical_ops = {
            "AND": lambda a, b: a & b,
            "OR": lambda a, b: a | b,
            "XOR": lambda a, b: a ^ b,
            "NOT": lambda a: ~a,
        }

        # Replace octal numbers with decimal equivalents
        decimal_expression = replace_octal_with_decimal(expression)

        # Tokenize the expression into numbers and operators
        tokens = re.split(r"(\bAND\b|\bOR\b|\bXOR\b|\bNOT\b)", decimal_expression)

        # Process the tokens to handle logical operations
        def process_tokens(tokens):
            # Stack for numbers and operators
            num_stack = []
            op_stack = []

            def apply_operator():
                op = op_stack.pop()
                if op == "NOT":
                    num = num_stack.pop()
                    num_stack.append(logical_ops[op](num))
                else:
                    num2 = num_stack.pop()
                    num1 = num_stack.pop()
                    num_stack.append(logical_ops[op](num1, num2))

            i = 0
            while i < len(tokens):
                token = tokens[i].strip()
                if token in logical_ops:
                    while (
                        op_stack
                        and op_stack[-1] in logical_ops
                        and logical_ops[op_stack[-1]]
                        in [logical_ops["AND"], logical_ops["OR"], logical_ops["XOR"]]
                    ):
                        apply_operator()
                    op_stack.append(token)
                else:
                    num_stack.append(int(token))
                i += 1

            while op_stack:
                apply_operator()

            return num_stack[0]

        # Evaluate the expression
        try:
            result = process_tokens(tokens)
        except ZeroDivisionError:
            return "Error: Division by zero"
        except Exception as e:
            return f"Error: {e}"

        # Convert the result back to octal
        return dec_to_oct(result)

    def binary_tobinary_64bit_segments(self, binary_number):
        # Ensure the binary number is represented in 64 bits
        padded_binary = format(int(str(binary_number), 2), "064b")
        # Split the padded binary into four 16-bit chunks
        return [padded_binary[i : i + 16] for i in range(0, 64, 16)]

    def evaluate_binary_expression(self, expression):
        # Define a helper function to convert binary to decimal
        def bin_to_dec(bin_str):
            return int(bin_str, 2)

        # Define a helper function to convert decimal to binary
        def dec_to_bin(dec_int):
            return bin(dec_int)[2:]

        # Replace binary numbers with their decimal equivalents in the expression
        def replace_binary_with_decimal(expr):
            binary_numbers = re.findall(r"[01]+", expr)
            for bin_num in binary_numbers:
                expr = expr.replace(bin_num, str(bin_to_dec(bin_num)), 1)
            return expr

        # Replace binary numbers with decimal equivalents
        decimal_expression = replace_binary_with_decimal(expression)

        # Evaluate the decimal expression
        try:
            result = eval(decimal_expression)
        except ZeroDivisionError:
            return "Error: Division by zero"
        except Exception as e:
            return f"Error: {e}"

        # Convert the result back to binary
        return dec_to_bin(result)

    def evaluate_binary_logical_expression(self, expression):
        # Define a helper function to convert binary to decimal
        def bin_to_dec(bin_str):
            return int(bin_str, 2)

        # Define a helper function to convert decimal to binary
        def dec_to_bin(dec_int):
            return bin(dec_int)[2:]

        # Replace binary numbers with their decimal equivalents in the expression
        def replace_binary_with_decimal(expr):
            binary_numbers = re.findall(r"\b[01]+\b", expr)
            for bin_num in binary_numbers:
                expr = expr.replace(bin_num, str(bin_to_dec(bin_num)), 1)
            return expr

        # Define the logical operators and their corresponding lambda functions
        logical_ops = {
            "AND": lambda a, b: a & b,
            "OR": lambda a, b: a | b,
            "XOR": lambda a, b: a ^ b,
            "NOT": lambda a: ~a,
        }

        # Replace binary numbers with decimal equivalents
        decimal_expression = replace_binary_with_decimal(expression)

        # Tokenize the expression into numbers and operators
        tokens = re.split(r"(\bAND\b|\bOR\b|\bXOR\b|\bNOT\b)", decimal_expression)

        # Process the tokens to handle logical operations
        def process_tokens(tokens):
            # Stack for numbers and operators
            num_stack = []
            op_stack = []

            def apply_operator():
                op = op_stack.pop()
                if op == "NOT":
                    num = num_stack.pop()
                    num_stack.append(logical_ops[op](num))
                else:
                    num2 = num_stack.pop()
                    num1 = num_stack.pop()
                    num_stack.append(logical_ops[op](num1, num2))

            i = 0
            while i < len(tokens):
                token = tokens[i].strip()
                if token in logical_ops:
                    while (
                        op_stack
                        and op_stack[-1] in logical_ops
                        and logical_ops[op_stack[-1]]
                        in [logical_ops["AND"], logical_ops["OR"], logical_ops["XOR"]]
                    ):
                        apply_operator()
                    op_stack.append(token)
                else:
                    num_stack.append(int(token))
                i += 1

            while op_stack:
                apply_operator()

            return num_stack[0]

        # Evaluate the expression
        try:
            result = process_tokens(tokens)
        except ZeroDivisionError:
            return "Error: Division by zero"
        except Exception as e:
            return f"Error: {e}"

        # Convert the result back to binary
        return dec_to_bin(result)

    def evaluate_hex_expression(self, expression):
        # Regular expression to find hexadecimal numbers (e.g., A, FF)
        hex_pattern = re.compile(r"\b[0-9a-fA-F]+\b")

        # Function to convert hexadecimal to decimal
        def hex_to_dec(match):
            return str(int(match.group(), 16))

        # Replace all hexadecimal numbers in the expression with their decimal equivalents
        decimal_expression = hex_pattern.sub(hex_to_dec, expression)

        try:
            # Evaluate the decimal expression
            result = eval(decimal_expression)
        except Exception as e:
            return f"Error evaluating expression: {e}"

        if isinstance(result, int):
            # Convert the integer result back to hexadecimal
            hex_result = hex(result).upper()[2:]
        elif isinstance(result, float):
            # Handle float result
            # Extract the integer and fractional parts
            integer_part = int(result)
            fractional_part = result - integer_part

            # Convert the integer part to hexadecimal
            hex_integer_part = hex(integer_part).upper()[2:]

            # Convert the fractional part to hexadecimal
            hex_fractional_part = []
            while fractional_part != 0:
                fractional_part *= 16
                hex_digit = int(fractional_part)
                hex_fractional_part.append(hex(hex_digit).upper()[2:])
                fractional_part -= hex_digit
                if (
                    len(hex_fractional_part) > 12
                ):  # Limit precision to avoid infinite loops
                    break
            hex_fractional_part = "".join(hex_fractional_part)

            # Combine both parts
            hex_result = f"{hex_integer_part}.{hex_fractional_part}"

        return hex_result

    def hexidecimal_to_hexidecimal_64bit_segments(self, hex_number):
        if not isinstance(hex_number, str):
            return "Error: Input must be a hexadecimal string."

        try:
            number = int(hex_number, 16)
        except ValueError:
            return "Error: Input must be a valid hexadecimal string."

        if number == 0:
            return ["0" * 16]  # Special case for zero, with a single 16-bit segment

        binary_result = bin(number)[2:]  # Get binary representation without '0b' prefix

        # Pad with leading zeros to make it 64 bits
        binary_result = binary_result.zfill(64)

        # Split into 16-bit segments
        segments = [binary_result[i : i + 16] for i in range(0, 64, 16)]

        return segments

    def logical_ops(self, string):
        # Define allowed operators
        allowed_operators = {"XOR", "OR", "AND", "NOT", "^", "|", "&", "~", "(", ")"}

        # Tokenize the string
        tokens = re.findall(r"\b\w+\b|[&|^~()]+", string)

        # Validate tokens
        for token in tokens:
            if token.isdigit():  # Check if the token is a digit (integer)
                continue
            elif (
                token in allowed_operators
            ):  # Check if the token is an allowed operator
                continue
            else:
                raise ValueError(f"Invalid token found: {token}")

        # Replace logical operators with corresponding symbols
        string = (
            string.replace("XOR", "^")
            .replace("OR", "|")
            .replace("AND", "&")
            .replace("NOT", "~")
        )

        # Final check to ensure the string contains only integers and allowed operators
        if not re.fullmatch(r"[0-9&|^~() ]+", string):
            return (
                string
                + ": The string contains invalid characters or floating-point numbers."
            )

        return eval(string)

    def bin_to_dec(self, binary_str):
        return int(binary_str, 2)

    def oct_to_dec(self, octal_str):
        return int(octal_str, 8)

    def hex_to_dec(self, hex_str):
        return int(hex_str, 16)

    def dec_to_bin(self, decimal_float):
        integer_part = int(decimal_float)
        fractional_part = decimal_float - integer_part
        integer_str = bin(integer_part)[2:]

        fractional_str = ""
        while fractional_part > 0 and len(fractional_str) < 10:
            fractional_part *= 2
            bit = int(fractional_part)
            fractional_str += str(bit)
            fractional_part -= bit

        return integer_str + ("." + fractional_str if fractional_str else "")

    def eval_expression(self, expression, mode):
        if mode == "binary":
            expression = re.sub(
                r"(\b[01]+)", lambda x: str(self.bin_to_dec(x.group(1))), expression
            )

        # Replace common operators for Python eval
        expression = expression.replace("×", "*").replace("÷", "/")

        # Evaluate the expression in decimal
        result = eval(expression)
        return result

    def sqrt_func(self, input_str, mode):
        input_str = input_str.strip().upper()

        # Handle the SQRT operation within the expression
        input_str = re.sub(
            r"SQRT\((.*?)\)",
            lambda m: str(math.sqrt(self.eval_expression(m.group(1), mode))),
            input_str,
        )
        input_str = re.sub(
            r"SQRT([0-9A-Fa-f]+)",
            lambda m: str(math.sqrt(self.eval_expression(m.group(1), mode))),
            input_str,
        )

        # Evaluate the final expression
        decimal_value = self.eval_expression(input_str, mode)

        if decimal_value.is_integer():
            decimal_value = int(decimal_value)

        # Convert back to the original mode
        if mode == "binary":
            result = self.dec_to_bin(decimal_value)
        elif mode == "decimal":
            result = decimal_value

        return result

    def update_operations_display(self):
        self.operations_list.clear()
        self.operations_list.addItems(self.operations)
        self.operations_list.scrollToBottom()
    
    def update_operations_display2(self):
        self.operations_list2.clear()
        self.operations_list2.addItems(self.operations2)
        self.operations_list2.scrollToBottom()

    def on_item_clicked(self, item):
        # This function will be called when an item is clicked
        item_text = item.text()
        self.Result.setText(item_text)  # Use the full item text directly

    def on_item_clicked2(self, item):
        # This function will be called when an item is clicked
        item_text = item.text()
        self.Result.setText(item_text)  # Use the full item text directly

    def retranslateUi(self, Programmer_calc):
        _translate = QtCore.QCoreApplication.translate
        Programmer_calc.setWindowTitle(_translate("Programmer_calc", "MainWindow"))
        self.Result.setText(_translate("Programmer_calc", ""))
        self.n8_63.setText(_translate("Programmer_calc", ""))
        self.h2_47.setText(_translate("Programmer_calc", ""))
        self.t6_31.setText(_translate("Programmer_calc", ""))
        self.nulla_15.setText(_translate("Programmer_calc", ""))
        self.comboBox_3.setItemText(0, _translate("Programmer_calc", "Decimális"))
        self.comboBox_3.setItemText(1, _translate("Programmer_calc", "Hexadecimális"))
        self.comboBox_3.setItemText(2, _translate("Programmer_calc", "Bináris"))
        self.comboBox_3.setItemText(3, _translate("Programmer_calc", "Oktális"))
        self.label_2.setText(_translate("Programmer_calc", ""))
        self.bel_zj.setText(_translate("Programmer_calc", "("))
        self.eight.setText(_translate("Programmer_calc", "8"))
        self.D_hex.setText(_translate("Programmer_calc", "D"))
        self.C_hex.setText(_translate("Programmer_calc", "C"))
        self.three.setText(_translate("Programmer_calc", "3"))
        self.minus.setText(_translate("Programmer_calc", "-"))
        self.dot.setText(_translate("Programmer_calc", "."))
        self.B_hex.setText(_translate("Programmer_calc", "B"))
        self.clear.setText(_translate("Programmer_calc", "DEL"))
        self.four.setText(_translate("Programmer_calc", "4"))
        self.jobb_zj.setText(_translate("Programmer_calc", ")"))
        self.one.setText(_translate("Programmer_calc", "1"))
        self.nine.setText(_translate("Programmer_calc", "9"))
        self.mod.setText(_translate("Programmer_calc", "mod"))
        self.A_hex.setText(_translate("Programmer_calc", "A"))
        self.zero.setText(_translate("Programmer_calc", "0"))
        self.two.setText(_translate("Programmer_calc", "2"))
        self.six.setText(_translate("Programmer_calc", "6"))
        self.F_hex.setText(_translate("Programmer_calc", "F"))
        self.plusz.setText(_translate("Programmer_calc", "+"))
        self.seven.setText(_translate("Programmer_calc", "7"))
        self.equal.setText(_translate("Programmer_calc", "="))
        self.five.setText(_translate("Programmer_calc", "5"))
        self.divide.setText(_translate("Programmer_calc", "/"))
        self.szorzas.setText(_translate("Programmer_calc", "x"))
        self.sqrt.setText(_translate("Programmer_calc", "sqrt"))
        self.E_hex.setText(_translate("Programmer_calc", "E"))
        self.pi.setText(_translate("Programmer_calc", "pi"))
        self.fakt.setText(_translate("Programmer_calc", "x!"))
        self.XOR.setText(_translate("Programmer_calc", "XOR"))
        self.abs.setText(_translate("Programmer_calc", "|x|"))
        self.NOT.setText(_translate("Programmer_calc", "NOT"))
        self.log.setText(_translate("Programmer_calc", "log"))
        self.x_xx_y.setText(_translate("Programmer_calc", "x^y"))
        self.ones.setText(_translate("Programmer_calc", "ones"))
        self.int_2.setText(_translate("Programmer_calc", "int"))
        self.x_xx_1.setText(_translate("Programmer_calc", "x^-1"))
        self.twos.setText(_translate("Programmer_calc", "twos"))
        self.AND.setText(_translate("Programmer_calc", "AND"))
        self.log2.setText(_translate("Programmer_calc", "log2"))
        self.OR.setText(_translate("Programmer_calc", "OR"))
        self.shift_left.setText(_translate("Programmer_calc", "<<"))
        self.shift_right.setText(_translate("Programmer_calc", ">>"))
        self.aaaa.setText(_translate("Programmer_calc", "á"))
        self.fact.setText(_translate("Programmer_calc", "fact"))
