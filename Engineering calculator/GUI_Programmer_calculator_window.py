# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Programmer_calc.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import math
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont
import re
from PyQt5.QtWidgets import QInputDialog


class Ui_Programmer_calculator(object):
    def __init__(self):
        self.operations = []  # List to store operations
        self.operations2 = []  # List to store operations

    def applyStylesheet(self, Programmer_calc):
        stylesheet = """
        QListWidget{
            background-color: #2E2E2E;
            color: #ffffff;
            font: 14pt;
            border: 1px solid #555555;
            border-radius: 5px;
        }
        QMainWindow {
            background-color: #2E2E2E;
        }
        QWidget#centralwidget {
            background-color: #2E2E2E;
        }
        QInputDialog{
            color: #FFFFFF;
            background-color: #2E2E2E;
            font-family: 'Courier New', Courier, monospace; /* Monospaced font */
            font-size: 10pt; /* Increase font size */
        }
        QLabel {
            color: #FFFFFF;
            font-family: 'Courier New', Courier, monospace; /* Monospaced font */
            font-size: 16pt; /* Increase font size */
            padding: 10px; /* Add padding */
            qproperty-alignment: 'AlignCenter'; /* Center align */
        }
        QComboBox, QTextEdit {
            background-color: #4E4E4E;
            color: #FFFFFF;
            border: 1px solid #555555;
            border-radius: 5px;
            padding: 5px;
        }
        QComboBox#shift_left, QComboBox#shift_right {
            background-color: #4E4E4E;
            font-size: 14pt;
            width: 50px;
            height: 50px;
            color: #FFFFFF;
            border: 1px solid #555555;
            border-radius: 5px;
            padding: 5px;
        }
        QComboBox QAbstractItemView {
            background-color: #4E4E4E;
            selection-background-color: #5E5E5E;
            color: #FFFFFF;
        }
        QLabel#label {
            font-family: 'Courier New', Courier, monospace; /* Monospaced font */
            font-size: 12pt;
            text-align: center;
        }
        QLabel#label_2 {
            font-size: 14pt;
            qproperty-alignment: 'AlignRight | AlignTrailing | AlignVCenter';
        }
        QPushButton#equal {
            background-color: #ff7300;
            width: 50px;
            height: 100%;
            color: #ffffff;
            border: 1px solid #555555;
            border-radius: 10px;
            padding: 10px;
        }
        QPushButton#equal:hover {
            background-color: #fc8e32;
        }
        QPushButton {
            background-color: #4E4E4E;
            font-size: 14pt;
            width: 50px;
            height: 50px;
            color: #FFFFFF;
            border: 1px solid #555555;
            border-radius: 10px;
            padding: 10px;
        }
        QLabel#h2_47, QLabel#n8_63, QLabel#nulla_15, QLabel#t6_31 {
            font-size: 14pt;
            font-family: 'Courier New', Courier, monospace;
            padding: 10px;
            qproperty-alignment: 'AlignCenter';
        }
        QPushButton:hover {
            background-color: #5E5E5E;
        }
        QPushButton:pressed {
            background-color: #6E6E6E;
        }
        """
        Programmer_calc.setStyleSheet(stylesheet)

    def back_to_mainwindow(self, Programmer_calc, MainWindow):
        Programmer_calc.close()
        MainWindow.show()

    def set_to_null(self, list1, list2):
        for i in list1:
            i.setEnabled(True)

        self.pi.setEnabled(True)
        self.sqrt.setEnabled(True)
        self.dot.setEnabled(True)
        for i in list2:
            i.setEnabled(True)

    def handle_combobox_3_change(self):
        text = self.comboBox_3.currentText()

        hex_buttons = [
            self.A_hex,
            self.B_hex,
            self.C_hex,
            self.D_hex,
            self.E_hex,
            self.F_hex,
        ]
        numbers = [
            self.zero,
            self.one,
            self.two,
            self.three,
            self.four,
            self.five,
            self.six,
            self.seven,
            self.eight,
            self.nine,
        ]

        if text == "Bináris":
            self.set_to_null(hex_buttons, numbers)
            for i in hex_buttons:
                i.setEnabled(False)

            self.pi.setEnabled(False)

            for i in range(2, len(numbers)):
                numbers[i].setEnabled(False)
        elif text == "Oktális":
            self.set_to_null(hex_buttons, numbers)
            self.pi.setEnabled(False)
            self.sqrt.setEnabled(False)
            for i in hex_buttons:
                i.setEnabled(False)

            for i in range(8, len(numbers)):
                numbers[i].setEnabled(False)
        elif text == "Decimális":
            self.set_to_null(hex_buttons, numbers)
            for i in hex_buttons:
                i.setEnabled(False)
        elif text == "Hexadecimális":
            self.set_to_null(hex_buttons, numbers)
            self.pi.setEnabled(False)
            self.sqrt.setEnabled(False)

    def setupUi(self, Programmer_calc, MainWindow):
        self.applyStylesheet(Programmer_calc)
        Programmer_calc.setObjectName("Programmer_calc")
        Programmer_calc.resize(1080, 725)
        Programmer_calc.setMinimumSize(QtCore.QSize(1080, 777))
        Programmer_calc.setMaximumSize(QtCore.QSize(1080, 777))
        Programmer_calc.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)
        self.centralwidget = QtWidgets.QWidget(Programmer_calc)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayoutWidget_2 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_2.setGeometry(QtCore.QRect(10, 80, 1051, 61))
        self.verticalLayoutWidget_2.setObjectName("verticalLayoutWidget_2")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_2)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.Result = QtWidgets.QLineEdit(self.verticalLayoutWidget_2)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(24)
        self.Result.setFont(font)
        self.Result.setObjectName("Result")
        # self.Result.textChanged.connect(self.on_label_text_changed)
        self.verticalLayout_2.addWidget(self.Result)
        self.horizontalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(10, 0, 1051, 81))
        self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")

        self.operations_list = QtWidgets.QListWidget(self.centralwidget)
        self.operations_list.setGeometry(
            QtCore.QRect(10, 600, 1051, 100)
        )  # Adjust size and position as needed
        self.operations_list.setObjectName("operations_list")
        self.horizontalLayout.addWidget(self.operations_list)
        self.operations_list.itemClicked.connect(self.on_item_clicked)

        self.operations_list2 = QtWidgets.QListWidget(self.centralwidget)
        self.operations_list2.setGeometry(
            QtCore.QRect(10, 600, 1051, 100)
        )  # Adjust size and position as needed
        self.operations_list2.setObjectName("operations_list")
        self.horizontalLayout.addWidget(self.operations_list2)
        self.operations_list2.itemClicked.connect(self.on_item_clicked2)

        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(14)
        self.verticalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 230, 1051, 161))
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        font = QFont("Times New Roman", 14)
        self.n8_63 = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.n8_63.setAlignment(Qt.AlignCenter)
        self.n8_63.setObjectName("n8_63")
        self.verticalLayout.addWidget(self.n8_63)

        self.h2_47 = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.h2_47.setAlignment(Qt.AlignCenter)
        self.h2_47.setObjectName("h2_47")
        self.verticalLayout.addWidget(self.h2_47)

        self.t6_31 = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.t6_31.setAlignment(Qt.AlignCenter)
        self.t6_31.setObjectName("t6_31")
        self.verticalLayout.addWidget(self.t6_31)

        self.nulla_15 = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.nulla_15.setAlignment(Qt.AlignCenter)
        self.nulla_15.setObjectName("nulla_15")
        self.verticalLayout.addWidget(self.nulla_15)
        self.horizontalLayoutWidget_2 = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget_2.setGeometry(QtCore.QRect(10, 131, 1051, 59))
        self.horizontalLayoutWidget_2.setObjectName("horizontalLayoutWidget_2")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget_2)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.comboBox_3 = QtWidgets.QComboBox(self.horizontalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.comboBox_3.setFont(font)
        self.comboBox_3.setObjectName("comboBox_3")
        self.comboBox_3.addItem("")
        self.comboBox_3.addItem("")
        self.comboBox_3.addItem("")
        self.comboBox_3.addItem("")
        self.horizontalLayout_2.addWidget(self.comboBox_3)
        spacerItem1 = QtWidgets.QSpacerItem(
            700, 0, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum
        )
        self.horizontalLayout_2.addItem(spacerItem1)
        self.label_2 = QtWidgets.QLabel(self.horizontalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(14)
        self.label_2.setFont(font)
        self.label_2.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_2.addWidget(self.label_2)
        self.horizontalLayoutWidget_3 = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget_3.setGeometry(QtCore.QRect(10, 390, 1051, 311))
        self.horizontalLayoutWidget_3.setObjectName("horizontalLayoutWidget_3")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget_3)
        self.horizontalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.gridLayout_for_numbers = QtWidgets.QGridLayout()
        self.gridLayout_for_numbers.setObjectName("gridLayout_for_numbers")
        self.bel_zj = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("("),
        )
        self.bel_zj.setObjectName("bel_zj")
        self.gridLayout_for_numbers.addWidget(self.bel_zj, 0, 1, 1, 1)
        self.eight = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("8"),
        )
        self.eight.setObjectName("eight")
        self.gridLayout_for_numbers.addWidget(self.eight, 3, 0, 1, 1)
        self.D_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("D"),
        )
        self.D_hex.setObjectName("D_hex")
        self.gridLayout_for_numbers.addWidget(self.D_hex, 1, 1, 1, 1)
        self.C_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("C"),
        )
        self.C_hex.setObjectName("C_hex")
        self.gridLayout_for_numbers.addWidget(self.C_hex, 1, 0, 1, 1)
        self.three = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("3"),
        )
        self.three.setObjectName("three")
        self.gridLayout_for_numbers.addWidget(self.three, 5, 3, 1, 1)
        self.minus = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("-"),
        )
        self.minus.setObjectName("minus")
        self.gridLayout_for_numbers.addWidget(self.minus, 4, 4, 1, 1)
        self.dot = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("."),
        )
        self.dot.setObjectName("dot")
        self.gridLayout_for_numbers.addWidget(self.dot, 3, 5, 1, 1)
        self.B_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("B"),
        )
        self.B_hex.setObjectName("B_hex")
        self.gridLayout_for_numbers.addWidget(self.B_hex, 3, 3, 1, 1)
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.clear = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("DEL"),
        )
        self.clear.setObjectName("clear")
        self.verticalLayout_4.addWidget(self.clear)
        self.gridLayout_for_numbers.addLayout(self.verticalLayout_4, 0, 0, 1, 1)
        self.four = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("4"),
        )
        self.four.setObjectName("four")
        self.gridLayout_for_numbers.addWidget(self.four, 4, 0, 1, 1)
        self.jobb_zj = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it(")"),
        )
        self.jobb_zj.setObjectName("jobb_zj")
        self.gridLayout_for_numbers.addWidget(self.jobb_zj, 0, 2, 1, 1)
        self.one = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("1"),
        )
        self.one.setObjectName("one")
        self.gridLayout_for_numbers.addWidget(self.one, 5, 1, 1, 1)
        self.nine = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("9"),
        )
        self.nine.setObjectName("nine")
        self.gridLayout_for_numbers.addWidget(self.nine, 3, 1, 1, 1)
        self.mod = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("%"),
        )
        self.mod.setObjectName("mod")
        self.gridLayout_for_numbers.addWidget(self.mod, 0, 3, 1, 1)
        self.A_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("A"),
        )
        self.A_hex.setObjectName("A_hex")
        self.gridLayout_for_numbers.addWidget(self.A_hex, 3, 2, 1, 1)
        self.zero = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("0"),
        )
        self.zero.setObjectName("zero")
        self.gridLayout_for_numbers.addWidget(self.zero, 5, 0, 1, 1)
        self.two = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("2"),
        )
        self.two.setObjectName("two")
        self.gridLayout_for_numbers.addWidget(self.two, 5, 2, 1, 1)
        self.six = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("6"),
        )
        self.six.setObjectName("six")
        self.gridLayout_for_numbers.addWidget(self.six, 4, 2, 1, 1)
        self.F_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("F"),
        )
        self.F_hex.setObjectName("F_hex")
        self.gridLayout_for_numbers.addWidget(self.F_hex, 1, 3, 1, 1)
        self.plusz = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("+"),
        )
        self.plusz.setObjectName("plusz")
        self.gridLayout_for_numbers.addWidget(self.plusz, 5, 4, 1, 1)
        self.seven = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("7"),
        )
        self.seven.setObjectName("seven")
        self.gridLayout_for_numbers.addWidget(self.seven, 4, 3, 1, 1)
        self.equal = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.evaluate_expression(),
        )
        self.equal.setObjectName("equal")
        self.gridLayout_for_numbers.addWidget(self.equal, 4, 5, 2, 1)
        self.five = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("5"),
        )
        self.five.setObjectName("five")
        self.gridLayout_for_numbers.addWidget(self.five, 4, 1, 1, 1)
        self.divide = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("/"),
        )
        self.divide.setObjectName("divide")
        self.gridLayout_for_numbers.addWidget(self.divide, 1, 4, 1, 1)
        self.szorzas = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("*"),
        )
        self.szorzas.setObjectName("szorzas")
        self.gridLayout_for_numbers.addWidget(self.szorzas, 3, 4, 1, 1)
        self.sqrt = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("SQRT"),
        )
        self.sqrt.setObjectName("sqrt")
        self.gridLayout_for_numbers.addWidget(self.sqrt, 1, 5, 1, 1)
        self.E_hex = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("E"),
        )
        self.E_hex.setObjectName("E_hex")
        self.gridLayout_for_numbers.addWidget(self.E_hex, 1, 2, 1, 1)
        self.pi = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("3.14"),
        )
        self.pi.setObjectName("pi")
        self.gridLayout_for_numbers.addWidget(self.pi, 0, 4, 1, 2)
        self.horizontalLayout_3.addLayout(self.gridLayout_for_numbers)
        self.gridLayout_for_special_buttons = QtWidgets.QGridLayout()
        self.gridLayout_for_special_buttons.setObjectName(
            "gridLayout_for_special_buttons"
        )
        self.fakt = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("!"),
        )
        self.fakt.setObjectName("fakt")
        self.gridLayout_for_special_buttons.addWidget(self.fakt, 3, 0, 1, 2)
        self.back = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.back_to_mainwindow(Programmer_calc, MainWindow),
        )
        self.back.setObjectName("back")
        self.back.setGeometry(QtCore.QRect(985, 710, 75, 23))
        self.gridLayout_for_special_buttons.addWidget(self.back, 4, 3, 1, 2)
        self.back.setEnabled(True)
        self.XOR = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it(" XOR ")
        )
        self.XOR.setObjectName("XOR")
        self.gridLayout_for_special_buttons.addWidget(self.XOR, 0, 4, 1, 1)

        self.abs = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("ABS "),
        )
        self.abs.setObjectName("abs")
        self.gridLayout_for_special_buttons.addWidget(self.abs, 3, 2, 1, 1)
        self.log = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("log "),
        )
        self.log.setObjectName("log")
        self.gridLayout_for_special_buttons.addWidget(self.log, 2, 4, 1, 1)
        self.x_xx_y = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("**"),
        )
        self.x_xx_y.setObjectName("x_xx_y")
        self.gridLayout_for_special_buttons.addWidget(self.x_xx_y, 2, 0, 1, 1)

        self.ones = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("ones "),
        )
        self.ones.setObjectName("ones")
        self.gridLayout_for_special_buttons.addWidget(self.ones, 1, 0, 1, 1)
        self.int_2 = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("int "),
        )
        self.int_2.setObjectName("int_2")
        self.gridLayout_for_special_buttons.addWidget(self.int_2, 2, 2, 1, 1)
        self.x_xx_1 = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("**-1"),
        )
        self.x_xx_1.setObjectName("x_xx_1")
        self.gridLayout_for_special_buttons.addWidget(self.x_xx_1, 2, 1, 1, 1)
        self.twos = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("twos "),
        )
        self.twos.setObjectName("twos")
        self.gridLayout_for_special_buttons.addWidget(self.twos, 1, 1, 1, 1)
        self.AND = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it(" AND ")
        )
        self.AND.setObjectName("AND")
        self.gridLayout_for_special_buttons.addWidget(self.AND, 1, 2, 1, 2)
        self.log2 = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("log2 "),
        )
        self.log2.setObjectName("log2")
        self.gridLayout_for_special_buttons.addWidget(self.log2, 2, 3, 1, 1)
        self.OR = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it(" OR ")
        )
        self.OR.setObjectName("OR")
        self.gridLayout_for_special_buttons.addWidget(self.OR, 1, 4, 1, 1)
        self.shift_left = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it("<<")
        )
        self.shift_left.setObjectName("shift_left")
        self.gridLayout_for_special_buttons.addWidget(self.shift_left, 0, 0, 1, 2)
        self.shift_right = QtWidgets.QPushButton(
            self.centralwidget, clicked=lambda: self.press_it(">>")
        )
        self.shift_right.setObjectName("shift_right")
        self.gridLayout_for_special_buttons.addWidget(self.shift_right, 0, 2, 1, 2)
        self.aaaa = QtWidgets.QPushButton(self.horizontalLayoutWidget_3)
        self.aaaa.setObjectName("aaaa")
        self.aaaa.clicked.connect(self.show_dialog)
        self.gridLayout_for_special_buttons.addWidget(self.aaaa, 3, 3, 1, 2)
        self.fact = QtWidgets.QPushButton(
            self.centralwidget,
            clicked=lambda: self.press_it("FACT"),
        )
        self.fact.setObjectName("fact")
        self.gridLayout_for_special_buttons.addWidget(self.fact, 4, 0, 1, 3)
        self.horizontalLayout_3.addLayout(self.gridLayout_for_special_buttons)
        Programmer_calc.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(Programmer_calc)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1083, 21))
        self.menubar.setObjectName("menubar")
        Programmer_calc.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(Programmer_calc)
        self.statusbar.setObjectName("statusbar")
        Programmer_calc.setStatusBar(self.statusbar)

        self.comboBox_3.currentTextChanged.connect(self.handle_combobox_3_change)
        self.retranslateUi(Programmer_calc)
        QtCore.QMetaObject.connectSlotsByName(Programmer_calc)

    def show_dialog(self):
        text, ok = QInputDialog.getText(
            self.centralwidget, "", "Adj meg egy karaktert:"
        )
        if ok and text and len(text) == 1:
            ascii_value = ord(text)
            current_mode = self.comboBox_3.currentText()

            if current_mode == "Decimális":
                converted_value = str(ascii_value)
            elif current_mode == "Hexadecimális":
                converted_value = hex(ascii_value)[
                    2:
                ].upper()  # Convert to hex and remove '0x' prefix
            elif current_mode == "Bináris":
                converted_value = bin(ascii_value)[
                    2:
                ]  # Convert to binary and remove '0b' prefix
            elif current_mode == "Oktális":
                converted_value = oct(ascii_value)[
                    2:
                ]  # Convert to octal and remove '0o' prefix

            self.Result.setText(converted_value)

    def press_it(self, pressed):
        if pressed == "DEL":
            self.Result.setText("0")
        elif self.Result.text() == "ERROR!" and pressed:
            self.Result.setText(pressed)
            # Check to see if it starts with 0 and delete the zero
        elif self.Result.text() == "0":
            self.Result.setText(pressed)
        # concatenate the pressed button with what was there already
        else:
            self.Result.setText(f"{self.Result.text()}{pressed}")

    def is_prime(self, n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    def factorize(self, n):
        if self.is_prime(n):
            return [n]

        factors = []
        divisor = 2
        while n >= 2:
            if n % divisor == 0:
                factors.append(divisor)
                n //= divisor
            else:
                divisor += 1
                while not self.is_prime(divisor):
                    divisor += 1
        return factors

    def convert_and_factorize(self, input_num):

        # Determine the base of the input number
        if input_num.startswith("0b"):
            base = 2
        elif input_num.startswith("0x"):
            base = 16
        elif input_num.startswith("0o"):
            base = 8
        else:
            base = 10

        # Convert the number to decimal
        decimal_number = int(input_num, base)

        # Factorize the decimal number
        factors = self.factorize(decimal_number)

        # Convert factors back to the original base
        if base == 2:
            factors_str = "*".join(bin(f)[2:] for f in factors)
        elif base == 16:
            factors_str = "*".join(hex(f)[2:] for f in factors).upper()
        elif base == 8:
            factors_str = "*".join(oct(f)[2:] for f in factors)
        else:
            factors_str = "*".join(map(str, factors))

        return factors_str

    def factorial(self, num_str, num_system):
        # Determine the base and convert to decimal
        if num_system == "binary":
            base = 2
        elif num_system == "octal":
            base = 8
        elif num_system == "hexadecimal":
            base = 16
        elif num_system == "decimal":
            base = 10
        else:
            raise ValueError("Invalid number system")

        # Convert to decimal float
        decimal_num = float(int(num_str, base)) if base != 10 else float(num_str)

        # Calculate factorial
        def calc_factorial(n):
            if n < 0:
                raise ValueError("Factorial is not defined for negative numbers")
            elif n == 0 or n == 1:
                return 1
            elif n != int(n):
                return math.gamma(n + 1)  # Gamma(n+1) is the factorial for non-integers
            else:
                return math.factorial(int(n))  # Use math.factorial for integer values

        factorial_result = calc_factorial(decimal_num)

        # Convert the result back to the original format
        if base == 2:
            result = bin(int(factorial_result))[2:]
        elif base == 8:
            result = oct(int(factorial_result))[2:]
        elif base == 16:
            result = hex(int(factorial_result))[2:].upper()
        else:
            result = str(factorial_result)

        return result

    def only_one_fact(self, string):
        cnt = 0
        for i in string:
            if i == "!":
                cnt += 1

        return cnt

    def evaluate_expression(self):
        screen = self.Result.text()
        operation = screen  # Store the current operation

        if self.comboBox_3.currentText() == "Decimális":
            if "twos" in screen:
                try:
                    number = screen.split("twos ")[1]
                    answer = self.twos_complement(number, 10)
                    print("#LOG: kettes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen kettes komlemens!")
            elif "log2" in screen:
                try:
                    print("#LOG: log")
                    answer = self.log_from_decimal(screen.split(" ")[1], 2)
                except:
                    answer = None
                    self.Result.setText("Helytelen faktoriális!")
            elif "log" in screen:
                try:
                    print("#LOG: log")
                    answer = self.log_from_decimal(screen.split(" ")[1], 10)
                except:
                    answer = None
                    self.Result.setText("Helytelen faktoriális!")
            elif "ABS" in screen:
                try:
                    print("#LOG: abs")
                    if "." in screen:
                        answer = abs(float((screen.split(" ")[1])))
                    else:
                        answer = abs(int((screen.split(" ")[1])))
                except:
                    answer = None
                    self.Result.setText("Helytelen abs!")
            elif "int" in screen:
                try:
                    answer = int(
                        self.round_down_number(
                            screen.split("int")[1], "decimal"
                        ).strip()
                    )
                    print("#LOG: kerekítés egészre")
                except:
                    answer = None
                    self.Result.setText("Helytelen kerekítés egészre!")
            elif "ones" in screen:
                try:
                    answer = self.ones_complement(screen.split("ones")[1], 10)
                    print("#LOG: egyes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen egyes komlemens!")
            elif (
                not self.contain_logical(screen)
                and self.contains_sqrt(screen)
                and self.only_one_fact(screen) == 0
            ):
                try:
                    answer = self.sqrt_func(screen, "decimal")
                    print("#LOG: csak gyökvonás")
                except:
                    answer = None
                    self.Result.setText("Helytelen gyökvonás!")
            elif "<<" in screen or ">>" in screen:
                print("#LOG: shiftelés")
                try:
                    if "<<" in screen:
                        num = screen.split("<<")[0]
                        cnt = screen.split("<<")[1]
                        answer = self.shift_left_func(cnt, num)
                    if ">>" in screen:
                        num = screen.split(">>")[0]
                        cnt = screen.split(">>")[1]
                        answer = self.shift_right_func(cnt, num)
                except:
                    answer = None
                    self.Result.setText("Helytelen shiftelés!")
            elif (
                self.contain_arithmetic(screen)
                and not self.contain_logical(screen)
                and self.only_one_fact(screen) == 0
            ):
                try:
                    answer = eval(screen)
                    print("#LOG: csak aritmetikai")
                except:
                    answer = None
                    self.Result.setText("Helytelen aritmetikai müvelet!")
            elif "FACT" in screen:
                try:
                    print("#LOG: FACT")
                    answer = self.convert_and_factorize(screen.split("FACT")[1])
                except:
                    answer = None
                    self.Result.setText("Helytelen factorizáció!")
            elif self.only_one_fact(screen) == 1 and "!" in screen:
                try:
                    print("#LOG: factorial")
                    answer = self.factorial(screen.split("!")[0], "decimal")
                except:
                    answer = None
                    self.Result.setText("Helytelen faktoriális!")
            elif not self.contain_arithmetic(screen) and self.contain_logical(screen):
                try:
                    print("#LOG: csak logikai")
                    answer = self.logical_ops(screen)
                except:
                    answer = None
                    self.Result.setText("Helytelen logikai!")
            else:
                try:
                    print("#LOG: egyébként")
                    answer = eval(screen)
                except:
                    self.Result.setText("ERROR!")
                    answer = None

            if answer is not None:
                self.Result.setText(str(answer))

                self.operations.append(f"{operation}")
                self.update_operations_display()

                self.operations2.append(f"{answer}")
                self.update_operations_display2()

            if type(answer) is int:
                binary_segments = self.decimal_to_decimal_64bit_segments(answer)
                self.n8_63.setText(f"64 {self.format_binary(binary_segments[0])} 48")
                self.h2_47.setText(f"47 {self.format_binary(binary_segments[1])} 32")
                self.t6_31.setText(f"31 {self.format_binary(binary_segments[2])} 16")
                self.nulla_15.setText(f"15 {self.format_binary(binary_segments[3])}  0")
            else:
                self.n8_63.setText(f"")
                self.h2_47.setText(f"")
                self.t6_31.setText(f"")
                self.nulla_15.setText(f"")
        elif self.comboBox_3.currentText() == "Oktális":
            answer = 0
            if "twos" in screen:
                print("#LOG: kettes komlemens")
                try:
                    number = screen.split(" ")[1]
                    answer = self.twos_complement(number, 8)
                    print("#LOG: kettes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen kettes komlemens!")
            elif "**-" in screen:
                try:
                    print("#LOG: negatív kitevőjű")
                    number = screen.split("**")[0]
                    kitevő = int(screen.split("**")[1])
                    answer = self.power_octal(number, kitevő)
                except:
                    answer = None
                    self.Result.setText("Helytelen negatív kitevőjű!")
            elif "<<" in screen or ">>" in screen:
                print("#LOG: shiftelés")
                try:
                    if "<<" in screen:
                        number = screen.split("<<")[0]
                        shift_amount = int(screen.split("<<")[1])
                        answer = self.shift_octal_custom("<<", shift_amount, number)
                    if ">>" in screen:
                        number = screen.split(">>")[0]
                        shift_amount = int(screen.split(">>")[1])
                        answer = self.shift_octal_custom(">>", shift_amount, number)
                except:
                    answer = None
                    self.Result.setText("Helytelen shiftelés!")
            elif "ABS" in screen:
                try:
                    print("#LOG: abs")
                    answer = float(self.absolute_octal(screen.split(" ")[1]))
                except:
                    answer = None
                    self.Result.setText("Helytelen abs!")
            elif "log2" in screen:
                try:
                    print("#LOG: log")
                    answer = self.log_from_octal(screen.split(" ")[1], 2)
                except:
                    answer = None
                    self.Result.setText("Helytelen 2 alapú logaritmikus!")
            elif "log" in screen:
                try:
                    print("#LOG: log")
                    answer = self.log_from_octal(screen.split(" ")[1], 10)
                except:
                    answer = None
                    self.Result.setText("Helytelen 10 alapú logaritmikus!")
            elif self.only_one_fact(screen) == 1 and "!" in screen:
                try:
                    print("#LOG: faktoriális")
                    answer = int(self.factorial(screen.split("!")[0], "octal"))
                except:
                    answer = None
                    self.Result.setText("Helytelen faktoriális!")
            elif "int" in screen:
                print("#LOG: kerekítés egészre")
                try:
                    answer = int(
                        self.round_down_number(screen.split("int")[1], "octal").strip()
                    )

                    print("#LOG: kerekítés egészre")
                except:
                    answer = None
                    self.Result.setText("Helytelen kerekítés egészre!")
            elif "ones" in screen:
                try:
                    number = screen.split(" ")[1]
                    answer = self.ones_complement(number, 8)
                    print("#LOG: egyes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen egyes komlemens!")
            elif self.contain_arithmetic(screen) and not self.contain_logical(screen):
                print("# Aritmetikus oktál")
                try:
                    if not "." in self.evaluate_octal_expression(screen):
                        answer = int(self.evaluate_octal_expression(screen))
                    else:
                        answer = self.evaluate_octal_expression(screen)
                except:
                    answer = None
                    self.Result.setText("Helytelen aritmetikai müvelet!")
            elif not self.contain_arithmetic(screen) and self.contain_logical(screen):
                print("#LOG: logikai oktál")
                try:
                    answer = int(self.evaluate_octal_logical_expression(screen))
                except:
                    answer = None
                    self.Result.setText("Helytelen logikai müvelet!")
            elif "FACT" in screen:
                print("#LOG: faktorizáció")
                try:
                    answer = self.convert_and_factorize("0o" + screen.split("FACT")[1])
                except:
                    answer = None
                    self.Result.setText("Helytelen faktorizáció!")
            else:
                print("#LOG: egyéb")
                try:
                    answer = int(self.evaluate_octal_expression(screen))
                except:
                    self.Result.setText("ERROR nem oktális érték!")
            if answer is not None:
                self.Result.setText(str(answer))

                self.operations.append(f"{operation}")
                self.update_operations_display()

                self.operations2.append(f"{answer}")
                self.update_operations_display2()
            if type(answer) is int:
                octal_segments = self.octal_octal_to_64bit_segments(answer)
                self.n8_63.setText(f"64 {self.format_binary(octal_segments[1])} 48")
                self.h2_47.setText(f"47 {self.format_binary(octal_segments[2])} 32")
                self.t6_31.setText(f"31 {self.format_binary(octal_segments[2])} 16")
                self.nulla_15.setText(f"15 {self.format_binary(octal_segments[3])} 0")
            else:
                self.n8_63.setText(f"")
                self.h2_47.setText(f"")
                self.t6_31.setText(f"")
                self.nulla_15.setText(f"")
        elif self.comboBox_3.currentText() == "Bináris":

            answer = 0
            if "twos" in screen:
                try:
                    number = screen.split(" ")[1]
                    answer = self.twos_complement(number, 2)
                    print("#LOG: kettes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen kettes komlemens!")
            elif (self.only_one_fact(screen) == 1 and "!" in screen and not self.contain_arithmetic(screen)):
                try:
                    print("#LOG: factorial")
                    answer = self.factorial(screen.split("!")[0], "binary")
                except:
                    answer = None
                    self.Result.setText("Helytelen faktoriális!")
            elif "int" in screen:
                try:
                    answer = self.round_down_number(screen.split("int")[1], "binary").strip()
                    print("#LOG: kerekítés egészre")
                except:
                    answer = None
                    self.Result.setText("Helytelen kerekítés egészre!")
            elif "log2" in screen:
                try:
                    print("#LOG: log")
                    answer = self.log_from_binary(screen.split(" ")[1], 2)
                except:
                    answer = None
                    self.Result.setText("Helytelen faktoriális!")
            elif "log" in screen:
                try:
                    print("#LOG: log")
                    answer = self.log_from_binary(screen.split(" ")[1], 10)
                except:
                    answer = None
                    self.Result.setText("Helytelen logaritmus!")
            elif "ABS" in screen:
                print("#LOG: abszolut érték")
                try:

                    answer = self.abs_binary(screen.split(" ")[1])
                except:
                    answer = None
                    self.Result.setText("Helytelen abs!")
            elif "ones" in screen:
                try:
                    answer = self.ones_complement(screen.split("ones")[1], 2)
                    print("#LOG: egyes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen egyes komlemens!")
            elif "<<" in screen or ">>" in screen:
                print("#LOG: shiftelés")
                try:
                    if "<<" in screen:
                        number = screen.split("<<")[0]
                        shift_amount = screen.split("<<")[1]
                        answer = self.shift_binary_custom("<<", shift_amount, number)
                    if ">>" in screen:
                        number = screen.split(">>")[0]
                        shift_amount = screen.split(">>")[1]
                        answer = self.shift_binary_custom(">>", shift_amount, number)
                except:
                    answer = None
                    self.Result.setText("Helytelen shiftelés!")
            elif not self.contain_logical(screen) and self.contains_sqrt(screen):
                print("#LOG: gyökvonás")
                try:
                    answer = self.sqrt_func(screen, "binary")
                except:
                    answer = None
                    self.Result.setText("ERROR helytelen gyökvonás!")
            elif self.contain_arithmetic(screen) and not self.contain_logical(screen):
                print("#LOG: aritmetikai müvelet")
                try:
                    answer = self.evaluate_binary_expression(screen)
                except:
                    answer = None
                    self.Result.setText("ERROR helytelen aritmetikai!")
            elif "FACT" in screen:
                print("#LOG: faktorizáció")
                try:
                    answer = self.convert_and_factorize("0b" + screen.split("FACT")[1])
                except:
                    answer = None
                    self.Result.setText("ERROR helytelen faktorizálás!")
            elif not self.contain_arithmetic(screen) and self.contain_logical(screen):
                print("#LOG: logikai")
                try:
                    answer = self.evaluate_binary_logical_expression(screen)
                except:
                    answer = None
                    self.Result.setText("ERROR: helytelen logikai kifejezés!")
            else:
                print("#LOG: egyéb")
                try:
                    answer = self.evaluate_binary_expression(screen)
                except:
                    self.Result.setText("ERROR nem bináris érték!")
            if answer is not None and answer is not False:
                self.Result.setText(str(answer))

                self.operations.append(f"{operation}")
                self.update_operations_display()

                self.operations2.append(f"{answer}")
                self.update_operations_display2()
            if type(answer) is str and not "." in answer and answer is not False:
                if type(answer) is str and not "." in answer and answer is not False:
                    try:
                        binary_segments = self.binary_tobinary_64bit_segments(answer)
                        if binary_segments is False:
                            raise ValueError("Error: Invalid binary input for 64-bit segmentation.")
                    except Exception as e:
                        print(e)
                        self.Result.setText("Nem ábrázolható 64 bit-en!")
                    else:
                        self.n8_63.setText(f"64 {self.format_binary(binary_segments[0])} 48")
                        self.h2_47.setText(f"47 {self.format_binary(binary_segments[1])} 32")
                        self.t6_31.setText(f"31 {self.format_binary(binary_segments[2])} 16")
                        self.nulla_15.setText(f"15 {self.format_binary(binary_segments[3])}  0")
            else:
                self.n8_63.setText(f"")
                self.h2_47.setText(f"")
                self.t6_31.setText(f"")
                self.nulla_15.setText(f"")
        elif self.comboBox_3.currentText() == "Hexadecimális":

            answer = 0
            if "twos" in screen:
                try:
                    number = screen.split("twos ")[1]
                    answer = self.twos_complement(number, 16)
                    print("#LOG: kettes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen kettes komlemens!")
            elif "log2" in screen:
                try:
                    print("#LOG: log")
                    answer = self.log_from_hex(screen.split(" ")[1], 2)
                except:
                    answer = None
                    self.Result.setText("Helytelen faktoriális!")
            elif "log" in screen:
                try:
                    print("#LOG: log")
                    answer = self.log_from_hex(screen.split(" ")[1], 10)
                except:
                    answer = None
                    self.Result.setText("Helytelen logaritmus!")
            elif "ABS" in screen:
                try:

                    answer = self.abs_hex(screen.split(" ")[1])
                except:
                    answer = None
                    self.Result.setText("Helytelen abs!")
            elif (
                self.only_one_fact(screen) == 1
                and "!" in screen
                and not self.contain_arithmetic(screen)
            ):
                try:
                    print("#LOG: factorial")
                    answer = self.factorial(screen.split("!")[0], "hexadecimal")
                except:
                    answer = None
                    self.Result.setText("Helytelen faktoriális!")
            elif "int" in screen:
                try:
                    answer = self.evaluate_hex_expression(
                        self.round_down_number(screen.split("int")[1], "hex").strip()
                    )
                    print("#LOG: kerekítés egészre")
                except:
                    answer = None
                    self.Result.setText("Helytelen kerekítés egészre!")
            elif "ones" in screen:
                try:
                    number = screen.split(" ")[1]
                    answer = self.ones_complement(number, 16)
                    print("#LOG: egyes komlemens")
                except:
                    answer = None
                    self.Result.setText("Helytelen egyes komlemens!")
            elif self.contain_arithmetic(screen) and not self.contain_logical(screen):
                try:
                    answer = self.evaluate_hex_expression(screen)
                except:
                    answer = None
                    self.Result.setText("Helytelen artimetikai!")
            elif not self.contain_arithmetic(screen) and self.contain_logical(screen):
                try:
                    answer = self.evaluate_logical_hex_expression(screen)
                except:
                    answer = None
                    self.Result.setText("Helytelen logikai!")
            elif "FACT" in screen:
                try:
                    if screen.split("FACT")[1] != "0":
                        answer = self.convert_and_factorize(
                            "0x" + screen.split("FACT")[1]
                        )
                    else:
                        answer = "0"
                except:
                    answer = None
                    self.Result.setText("Helytelen faktorizáció!")
            elif "<<" in screen or ">>" in screen:
                if "<<" in screen:
                    num = screen.split("<<")[0]
                    cnt = screen.split("<<")[1]
                    answer = self.hex_shift_left_func(cnt, num)
                if ">>" in screen:
                    num = screen.split(">>")[0]
                    cnt = screen.split(">>")[1]
                    answer = self.hex_shift_right_func(cnt, num)
            else:
                try:
                    answer = self.evaluate_hex_expression(screen)
                except:
                    self.Result.setText("ERROR nem hexa érték!")

            if answer is not None:
                self.Result.setText(str(answer))

                self.operations.append(f"{operation}")
                self.update_operations_display()

                self.operations2.append(f"{answer}")
                self.update_operations_display2()

            if (
                isinstance(answer, str)
                and not "." in answer
                and not "*" in answer
                and answer != "0"
            ):
                binary_segments = self.hexidecimal_to_hexidecimal_64bit_segments(
                    str(answer)
                )
                self.n8_63.setText(f"64 {self.format_binary(binary_segments[0])} 48")
                self.h2_47.setText(f"47 {self.format_binary(binary_segments[1])} 32")
                self.t6_31.setText(f"31 {self.format_binary(binary_segments[2])} 16")
                self.nulla_15.setText(f"15 {self.format_binary(binary_segments[3])}  0")
            else:
                self.n8_63.setText(f"")
                self.h2_47.setText(f"")
                self.t6_31.setText(f"")
                self.nulla_15.setText(f"")

    def twos_complement(self, number: str, base: int) -> str:
        # Convert the input number to an integer
        if base == 2:
            int_number = int(number, 2)
        elif base == 8:
            int_number = int(number, 8)
        elif base == 10:
            int_number = int(number)
        elif base == 16:
            int_number = int(number, 16)
        else:
            raise ValueError("Base must be one of 2, 8, 10, or 16")

        # Calculate one's complement by flipping the bits
        max_num = (1 << 64) - 1
        ones_complement_int = int_number ^ max_num

        # Calculate two's complement by adding one to the one's complement result
        twos_complement_int = ones_complement_int + 1
        if '-' in number:
            if base == 2:
                result = bin(twos_complement_int)[3:].zfill(64)  # Remove the '0b' prefix and pad with zeros
            elif base == 8:
                result = oct(twos_complement_int)[3:].zfill(64 // 3)  # Remove the '0o' prefix and pad with zeros
            elif base == 10:
                result = str(twos_complement_int)  # No prefix for decimal
            elif base == 16:
                result = hex(twos_complement_int)[3:].upper().zfill(64 // 4)  # Remove the '0x' prefix and pad with zeros
        else:
            if base == 2:
                result = bin(twos_complement_int)[2:].zfill(64)  # Remove the '0b' prefix and pad with zeros
            elif base == 8:
                result = oct(twos_complement_int)[2:].zfill(64 // 3)  # Remove the '0o' prefix and pad with zeros
            elif base == 10:
                result = str(twos_complement_int)  # No prefix for decimal
            elif base == 16:
                result = hex(twos_complement_int)[2:].upper().zfill(64 // 4)  # Remove the '0x' prefix and pad with zeros
        
        return result

    def ones_complement(self, number: str, base: int) -> str:
        if '-' in number:
            number = number.replace("-", "")
        # Convert the input number to an integer
        if base == 2:
            int_number = int(number, 2)
        elif base == 8:
            int_number = int(number, 8)
        elif base == 10:
            int_number = int(number)
        elif base == 16:
            int_number = int(number, 16)
        else:
            raise ValueError("Base must be one of 2, 8, 10, or 16")

        # Calculate one's complement by flipping the bits
        max_num = (1 << 64) - 1
        ones_complement_int = int_number ^ max_num

        # Convert back to the original base
        if base == 2:
            result = bin(ones_complement_int)[2:].zfill(
                64
            )  # Remove the '0b' prefix and pad with zeros
        elif base == 8:
            result = oct(ones_complement_int)[2:].zfill(
                64 // 3
            )  # Remove the '0o' prefix and pad with zeros
        elif base == 10:
            result = ones_complement_int
        elif base == 16:
            result = (
                hex(ones_complement_int)[2:].upper().zfill(64 // 4)
            )  # Remove the '0x' prefix and pad with zeros

        return result

    def round_down_number(self, number: str, mode: str) -> str:
        if mode not in {"binary", "decimal", "octal", "hex"}:
            raise ValueError(
                "Invalid mode. Choose from 'binary', 'decimal', 'octal', or 'hex'."
            )

        negative = number.startswith("-")
        if negative:
            number = number[1:]

        if "." in number:
            integer_part, _ = number.split(".")
        else:
            integer_part = number

        if negative:
            integer_part = "-" + integer_part

        return integer_part

    def shift_left_func(self, num: str, number: str):
        # Ensure the input number is an integer
        if not number.isdigit():
            return f"{number}: a megadott érték nem egész szám"

        # Calculate the new number by shifting to the left
        new_number = int(number) << int(num)

        # Return the new number as a string
        return new_number

    def shift_right_func(self, num: str, number: str):
        # Ensure the input number is an integer
        if not number.isdigit():
            return f"{number}: a megadott érték nem egész szám"

        # Calculate the new number by shifting to the right
        new_number = int(number) >> int(num)

        # Return the new number as a string
        return new_number

    def abs_hex(self, hex_str):
        """
        Return the absolute value of a hexadecimal number given as a string.

        Parameters:
        hex_str (str): The hexadecimal string representing the number.

        Returns:
        str: The absolute value of the hexadecimal number in hexadecimal format.
        """

        def hex_to_decimal(hex_str):
            """Convert a hexadecimal string to a decimal float."""
            if "." in hex_str:
                int_part, frac_part = hex_str.split(".")
                int_value = int(int_part, 16)
                frac_value = sum(
                    int(digit, 16) * 16**-i for i, digit in enumerate(frac_part, 1)
                )
                return int_value + frac_value
            else:
                return int(hex_str, 16)

        def decimal_to_hex(decimal_num):
            """Convert a decimal number to a hexadecimal string."""
            if decimal_num == 0:
                return "0.0"

            int_part = int(decimal_num)
            frac_part = decimal_num - int_part

            int_hex = hex(int_part).lstrip("0x").upper() + "."

            frac_hex = ""
            while frac_part:
                frac_part *= 16
                digit = int(frac_part)
                frac_part -= digit
                frac_hex += hex(digit).lstrip("0x").upper()
                if (
                    len(frac_hex) > 8
                ):  # limiting the length of the fractional part to 8 digits
                    break

            return int_hex + frac_hex if frac_hex else int_hex.rstrip(".")

            # Remove the negative sign if it exists

        if hex_str.startswith("-"):
            hex_str = hex_str[1:]

        # Convert hexadecimal string to decimal
        decimal_value = hex_to_decimal(hex_str)

        # Get the absolute value
        abs_value = abs(decimal_value)

        # Convert the absolute decimal value back to a hexadecimal string
        return decimal_to_hex(abs_value)

    def log_from_hex(self, hex_str, base=10):
        """
        Calculate the logarithm of a hexadecimal number and return the result in binary and hexadecimal formats.

        Parameters:
        hex_str (str): The hexadecimal string representing the number.
        base (int): The base of the logarithm (default is 10, can also be 2).

        Returns:
        tuple: The logarithm of the hexadecimal number in binary and hexadecimal formats, limited to 8 decimal places.
        """

        def hex_to_decimal(hex_str):
            """Convert a hexadecimal string to a decimal float."""
            return int(hex_str, 16)

        def float_to_binary(value):
            """Convert a float to a binary string limited to 8 decimal places."""
            if value == 0:
                return "0.0"

            int_part = int(value)
            frac_part = value - int_part

            int_bin = bin(int_part).lstrip("0b") + "."

            frac_bin = ""
            for _ in range(8):
                frac_part *= 2
                bit = int(frac_part)
                frac_part -= bit
                frac_bin += str(bit)
                if frac_part == 0:
                    break

            return int_bin + frac_bin

        def float_to_hex(value):
            """Convert a float to a hexadecimal string limited to 8 decimal places."""
            if value == 0:
                return "0.0"

            int_part = int(value)
            frac_part = value - int_part

            int_hex = hex(int_part).lstrip("0x").upper() + "."

            frac_hex = ""
            for _ in range(8):
                frac_part *= 16
                digit = int(frac_part)
                frac_part -= digit
                frac_hex += hex(digit).lstrip("0x").upper()
                if frac_part == 0:
                    break

            return int_hex + frac_hex

        try:
            # Convert the hexadecimal string to a decimal number
            decimal_value = hex_to_decimal(hex_str)

            # Check for valid base
            if base not in [2, 10]:
                return "Invalid base. Only base 2 and base 10 are supported."

            # Calculate the logarithm of the decimal value
            log_value = math.log(decimal_value, base)

            # Convert the result to binary and hexadecimal strings
            log_hex = float_to_hex(log_value)

            return log_hex
        except ValueError:
            return False

    def is_valid_hex(self, number: str) -> bool:
        try:
            int(number, 16)
            return True
        except ValueError:
            return False

    def hex_shift_left_func(self, num: str, hex_number: str) -> str:
        # Ensure the input hex number is valid
        if not self.is_valid_hex(hex_number):
            raise ValueError("The provided number is not a valid hexadecimal")

        new_number = int(hex_number, 16) << int(num)

        return hex(new_number)[2:].upper()

    def hex_shift_right_func(self, num: str, hex_number: str) -> str:
        # Ensure the input hex number is valid
        if not self.is_valid_hex(hex_number):
            raise ValueError("The provided number is not a valid hexadecimal")

        # Calculate the new number by shifting to the right
        new_number = int(hex_number, 16) >> int(num)

        # Return the new number as a hexadecimal string
        return (hex(new_number))[2:].upper()

    def evaluate_logical_hex_expression(self, expression: str) -> str:
        # Split the expression into parts
        tokens = expression.split()

        # Convert the first hex number to an integer
        result = int(tokens[0], 16)

        # Iterate over the tokens and perform operations
        i = 1
        while i < len(tokens):
            operator = tokens[i]
            next_num = int(tokens[i + 1], 16)

            if operator == "OR":
                result |= next_num
            elif operator == "XOR":
                result ^= next_num
            elif operator == "AND":
                result &= next_num

            i += 2

        # Convert the result back to a hexadecimal string and return it
        return hex(result).upper()[2:]

    def contains_sqrt(self, string):
        for i in string:
            if "SQRT" in string:
                return True
        return False

    def contain_arithmetic(self, string):
        contains_arithmetic = False
        arithmetic_exp = ["*", "/", "%", "-", "+"]

        for op in arithmetic_exp:
            if op in string:
                contains_arithmetic = True
                break

        return contains_arithmetic

    def contain_logical(self, string):
        contains_logical = False
        logical_exp = ["AND", "OR", "XOR", "NOT"]

        for op in logical_exp:
            if op in string:
                contains_logical = True
                break

        return contains_logical

    def format_binary(self, binary_string):
        # Insert a space every four characters
        formatted_string = " ".join(
            binary_string[i : i + 4] for i in range(0, len(binary_string), 4)
        )
        return formatted_string

    def decimal_to_decimal_64bit_segments(self, number):
        if not isinstance(number, int):
            return "Error: Input must be an integer."

        is_negative = number < 0

        # Convert decimal to binary string
        if is_negative:
            # Convert to a full 64-bit binary number with two's complement for negative numbers
            binary_string = bin((1 << 64) + number)[2:]
        else:
            binary_string = bin(number)[2:]

        # Pad with leading zeros to make it 64 bits
        padded_binary = binary_string.zfill(64)

        # Ensure it is exactly 64 bits by taking the last 64 bits
        padded_binary = padded_binary[-64:]

        # Split into 16-bit chunks
        chunks = [padded_binary[i : i + 16] for i in range(0, 64, 16)]

        return chunks

    def octal_octal_to_64bit_segments(self, octal_number):
        is_negative = octal_number < 0

        # Convert octal to binary string
        binary_string = bin(int(str(abs(octal_number)), 8))[2:]

        if is_negative:
            # Convert to a full 64-bit binary number with two's complement for negative numbers
            binary_string = bin((1 << 64) - int(binary_string, 2))[2:]

        # Pad with leading zeros to make it 64 bits
        padded_binary = binary_string.zfill(64)

        # Ensure it is exactly 64 bits by taking the last 64 bits
        padded_binary = padded_binary[-64:]

        # Split into 16-bit chunks
        chunks = [padded_binary[i : i + 16] for i in range(0, 64, 16)]

        return chunks

    def evaluate_octal_expression(self, expression):
        # Define a helper function to convert octal to decimal
        def oct_to_dec(oct_str):
            return int(oct_str, 8)

        # Define a helper function to convert decimal to octal
        def dec_to_oct(dec_number):
            if isinstance(dec_number, float):
                integer_part = int(dec_number)
                fractional_part = dec_number - integer_part
                octal_integer = oct(integer_part)[2:]
                octal_fractional = ""
                for _ in range(10):  # Limit the fractional precision
                    fractional_part *= 8
                    octal_fractional += str(int(fractional_part))
                    fractional_part -= int(fractional_part)
                return f"{octal_integer}.{octal_fractional}".rstrip("0").rstrip(".")
            elif dec_number < 0:
                return "-" + oct(abs(int(dec_number)))[2:]
            return oct(int(dec_number))[2:]

        # Replace octal numbers with their decimal equivalents in the expression
        def replace_octal_with_decimal(expr):
            octal_numbers = re.findall(r"-?[0-7]+", expr)
            for oct_num in octal_numbers:
                expr = expr.replace(oct_num, str(oct_to_dec(oct_num)), 1)
            return expr

        # Replace octal numbers with decimal equivalents
        decimal_expression = replace_octal_with_decimal(expression)

        result = eval(decimal_expression)

        # Convert the result back to octal
        return dec_to_oct(result)

    def evaluate_octal_logical_expression(self, expression):
        # Define a helper function to convert octal to decimal
        def oct_to_dec(oct_str):
            return int(oct_str, 8)

        # Define a helper function to convert decimal to octal
        def dec_to_oct(dec_int):
            return oct(dec_int)[2:]

        # Replace octal numbers with their decimal equivalents in the expression
        def replace_octal_with_decimal(expr):
            octal_numbers = re.findall(r"\b[0-7]+\b", expr)
            for oct_num in octal_numbers:
                expr = expr.replace(oct_num, str(oct_to_dec(oct_num)), 1)
            return expr

        # Define the logical operators and their corresponding lambda functions
        logical_ops = {
            "AND": lambda a, b: a & b,
            "OR": lambda a, b: a | b,
            "XOR": lambda a, b: a ^ b,
            "NOT": lambda a: ~a
            & (
                (1 << 63) - 1
            ),  # Ensure NOT operation results in a 63-bit unsigned value
        }

        # Replace octal numbers with decimal equivalents
        decimal_expression = replace_octal_with_decimal(expression)

        # Tokenize the expression into numbers and operators
        tokens = re.split(r"(\bAND\b|\bOR\b|\bXOR\b|\bNOT\b|\s+)", decimal_expression)
        tokens = [token.strip() for token in tokens if token.strip()]

        # Process the tokens to handle logical operations
        def process_tokens(tokens):
            # Stack for numbers and operators
            num_stack = []
            op_stack = []

            def apply_operator():
                op = op_stack.pop()
                if op == "NOT":
                    num = num_stack.pop()
                    num_stack.append(logical_ops[op](num))
                else:
                    num2 = num_stack.pop()
                    num1 = num_stack.pop()
                    num_stack.append(logical_ops[op](num1, num2))

            i = 0
            while i < len(tokens):
                token = tokens[i]
                if token in logical_ops:
                    if token == "NOT":
                        op_stack.append(token)
                    else:
                        while op_stack and op_stack[-1] in logical_ops:
                            apply_operator()
                        op_stack.append(token)
                else:
                    num_stack.append(int(token))
                    while op_stack and op_stack[-1] == "NOT":
                        apply_operator()
                i += 1

            while op_stack:
                apply_operator()

            return num_stack[0]

        # Evaluate the expression
        try:
            result = process_tokens(tokens)
        except ZeroDivisionError:
            return "Error: Division by zero"
        except Exception as e:
            return f"Error: {e}"

        # Convert the result back to octal
        octal_result = dec_to_oct(result)

        # Ensure the result is in 64-bit octal format and starts with 1
        if "NOT" in expression:
            octal_result = octal_result.zfill(22)
            if not octal_result.startswith("1"):
                octal_result = "1" + octal_result[1:]

        return octal_result

    def shift_octal_custom(self, operation, shift_amount, number):
        octal_value = int(number, 8)
        if operation == "<<":
            shifted_value = octal_value << shift_amount
        elif operation == ">>":
            shifted_value = octal_value >> shift_amount
        else:
            return None

        return int(str(oct(shifted_value))[2:])

    def absolute_octal(self, octal_str: str) -> str:
        if '.' in octal_str:
            # Handle both integer and fractional parts separately
            integer_part, fractional_part = octal_str.split('.')
            
            # Convert integer part from octal to decimal
            decimal_integer = int(integer_part, 8)
            abs_decimal_integer = abs(decimal_integer)
            
            # Convert fractional part from octal to decimal
            decimal_fractional = sum(
                int(digit, 8) * (8 ** -(index + 1)) for index, digit in enumerate(fractional_part)
            )
            abs_decimal_fractional = abs(decimal_fractional)
            
            # Combine the integer and fractional parts back into a single decimal number
            abs_decimal_number = abs_decimal_integer + abs_decimal_fractional
            
            # Convert the absolute decimal number back to octal
            abs_octal_integer = oct(abs_decimal_integer)[2:]
            
            # Convert the fractional part back to octal
            abs_octal_fractional = []
            fractional = abs_decimal_fractional
            for _ in range(10):  # Limit the precision to 10 digits
                fractional *= 8
                digit = int(fractional)
                abs_octal_fractional.append(str(digit))
                fractional -= digit
                if fractional == 0:
                    break
            
            # Return the combined absolute octal string
            return abs_octal_integer + '.' + ''.join(abs_octal_fractional)
        else:
            # Handle the integer-only case
            decimal_number = int(octal_str, 8)
            abs_decimal = abs(decimal_number)
            return oct(abs_decimal)[2:]

    def float_to_octal(self, f):
        """
        Convert a floating-point number to its octal representation as a string.

        Parameters:
        f (float): The floating-point number to convert.

        Returns:
        str: The octal representation of the floating-point number.
        """
        if f < 0:
            sign = "-"
            f = -f
        else:
            sign = ""

        # Separate the integer part and the fractional part
        integer_part = int(f)
        fractional_part = f - integer_part

        # Convert the integer part to octal
        octal_integer = oct(integer_part)[2:]

        # Convert the fractional part to octal
        octal_fraction = ""
        while (
            fractional_part != 0 and len(octal_fraction) < 12
        ):  # limit length to prevent infinite loop
            fractional_part *= 8
            digit = int(fractional_part)
            octal_fraction += str(digit)
            fractional_part -= digit

        return sign + octal_integer + "." + octal_fraction

    def power_octal(self, octal_str, power_value):
        """
        Calculate the result of raising an octal number to a given power and return the result as an octal string.

        Parameters:
        octal_str (str): The octal number as a string.
        power_value (float): The power to which the octal number is to be raised.

        Returns:
        str: The octal representation of the result after exponentiation.
        """
        
        # Convert the octal string to a decimal number
        decimal_value = int(octal_str, 8)

        # Perform the power operation
        result_value = decimal_value**power_value

        # Convert the result back to an octal string with fraction handling
        octal_result = self.float_to_octal2(result_value)

        return octal_result

    def float_to_octal2(self, f):
        """
        Convert a floating-point number to its octal representation as a string.

        Parameters:
        f (float): The floating-point number to convert.

        Returns:
        str: The octal representation of the floating-point number.
        """
        if f < 0:
            sign = "-"
            f = -f
        else:
            sign = ""

        # Separate the integer part and the fractional part
        integer_part = int(f)
        fractional_part = f - integer_part

        # Convert the integer part to octal
        octal_integer = oct(integer_part)[2:]

        # Convert the fractional part to octal
        octal_fraction = ""
        while (
            fractional_part != 0 and len(octal_fraction) < 12
        ):  # limit length to prevent infinite loop
            fractional_part *= 8
            digit = int(fractional_part)
            octal_fraction += str(digit)
            fractional_part -= digit

        return sign + octal_integer + ("." + octal_fraction if octal_fraction else "")

    def log_from_binary(self, binary_str, base=10):
        """
        Calculate the logarithm of a binary number and return the result in binary format.

        Parameters:
        binary_str (str): The binary string representing the binary number.
        base (int): The base of the logarithm (default is 10, can also be 2).

        Returns:
        str: The logarithm of the binary number in binary format, limited to 8 decimal places.
        """

        def binary_to_decimal(binary_str):
            """Convert a binary string to a decimal float."""
            return int(binary_str, 2)

        def float_to_binary(value):
            """Convert a float to a binary string limited to 8 decimal places."""
            if value == 0:
                return "0.0"

            int_part = int(value)
            frac_part = value - int_part

            int_bin = bin(int_part).lstrip("0b")
            if int_bin == "":
                int_bin = "0"  # Handle the case where the integer part is zero

            frac_bin = ""
            for _ in range(8):
                frac_part *= 2
                bit = int(frac_part)
                frac_part -= bit
                frac_bin += str(bit)
                if frac_part == 0:
                    break

            return int_bin + "." + frac_bin

        # Convert the binary string to a decimal number
        decimal_value = binary_to_decimal(binary_str)

        # Check for valid base
        if base not in [2, 10]:
            return "Invalid base. Only base 2 and base 10 are supported."

        # Calculate the logarithm of the decimal value
        log_value = math.log(decimal_value, base)

        # Convert the result to a binary string
        log_binary = float_to_binary(log_value)

        return log_binary

    def log_from_decimal(self, decimal_str, base=10):
        """
        Calculate the logarithm of a decimal number and return the result.

        Parameters:
        decimal_str (str): The decimal number as a string.
        base (int): The base of the logarithm (default is 10, can also be 2).

        Returns:
        float: The logarithm of the decimal number.
        """
        try:
            # Convert the decimal string to a float
            decimal_value = float(decimal_str)

            # Check for valid base
            if base not in [2, 10]:
                return "Invalid base. Only base 2 and base 10 are supported."

            # Calculate the logarithm of the decimal value
            log_value = math.log(decimal_value, base)

            return log_value
        except ValueError:
            return "Helytelen decimális logaritmus számolás!"

    def log_from_octal(self, octal_str, base=10):
        """
        Calculate the logarithm of an octal number and return the result in both decimal and octal format.

        Parameters:
        octal_str (str): The octal number as a string.
        base (int): The base of the logarithm (default is 10).

        Returns:
        tuple: A tuple containing the logarithm of the octal number in decimal and octal format.
        """
        # Convert the octal string to a decimal integer
        decimal_value = int(octal_str, 8)

        # Calculate the logarithm of the decimal value
        log_value = math.log(decimal_value, base)

        # Convert the logarithm result to octal float representation
        log_value_octal = self.float_to_octal(log_value)

        return log_value_octal

    def binary_tobinary_64bit_segments(self, binary_number):
        if not isinstance(binary_number, str):
            return "Error: Input must be a binary string."

        try:
            if binary_number[0] == "-":
                # Handle negative binary numbers
                binary_value = int(binary_number, 2)
                if binary_value >= 0:
                    raise ValueError(
                        "Invalid input: expected a negative number for two's complement representation."
                    )
                # Calculate the two's complement for a 64-bit representation
                padded_binary = format((1 << 64) + binary_value, "064b")
            else:
                # Handle positive binary numbers
                binary_value = int(binary_number, 2)
                padded_binary = format(binary_value, "064b")

            # Split the padded binary into four 16-bit chunks
            chunks = [padded_binary[i : i + 16] for i in range(0, 64, 16)]

            return chunks
        except:
            return False

    def evaluate_binary_expression(self, expression):
        # Define a helper function to convert binary to decimal
        def bin_to_dec(bin_str):
            if bin_str.startswith("-"):
                return -int(bin_str[1:], 2)
            return int(bin_str, 2)

        # Define a helper function to convert decimal to binary
        def dec_to_bin(dec_int):
            if dec_int < 0:
                return "-" + bin(-int(dec_int))[2:]
            return bin(int(dec_int))[2:]

        # Replace binary numbers with their decimal equivalents in the expression
        def replace_binary_with_decimal(expr):
            binary_numbers = re.findall(r"-?[01]+", expr)
            for bin_num in binary_numbers:
                expr = expr.replace(bin_num, str(bin_to_dec(bin_num)), 1)
            return expr

        # Replace binary numbers with decimal equivalents
        decimal_expression = replace_binary_with_decimal(expression)

        result = eval(decimal_expression)

        # Convert the result back to binary, including handling of fractions
        if isinstance(result, float):
            sign = "-" if result < 0 else ""
            integer_part = abs(int(result))
            fractional_part = abs(result) - integer_part
            binary_result = dec_to_bin(integer_part)
            if fractional_part > 0:
                binary_fraction = []
                while (
                    fractional_part and len(binary_fraction) < 10
                ):  # Limit to 10 fractional bits for simplicity
                    fractional_part *= 2
                    bit = int(fractional_part)
                    binary_fraction.append(str(bit))
                    fractional_part -= bit
                binary_result += "." + "".join(binary_fraction)
            return sign + binary_result

        return dec_to_bin(result)

    def evaluate_binary_logical_expression(self, expression):
        # Define a helper function to convert binary to decimal
        def bin_to_dec(bin_str):
            return int(bin_str, 2)

        # Define a helper function to convert decimal to binary
        def dec_to_bin(dec_int):
            return bin(dec_int)[2:]  # Convert to binary without leading '0b' and remove padding

        # Replace binary numbers with their decimal equivalents in the expression
        def replace_binary_with_decimal(expr):
            binary_numbers = re.findall(r"\b[01]+\b", expr)
            for bin_num in binary_numbers:
                expr = expr.replace(bin_num, str(bin_to_dec(bin_num)), 1)
            return expr

        # Define the logical operators and their corresponding lambda functions
        logical_ops = {
            "AND": lambda a, b: a & b,
            "OR": lambda a, b: a | b,
            "XOR": lambda a, b: a ^ b,
            "NOT": lambda a: ~a & 0xFFFFFFFFFFFFFFFF,  # Ensure 64-bit representation for NOT
        }

        # Replace binary numbers with decimal equivalents
        decimal_expression = replace_binary_with_decimal(expression)

        # Tokenize the expression into numbers and operators
        tokens = re.split(r"(\bAND\b|\bOR\b|\bXOR\b|\bNOT\b)", decimal_expression)
        tokens = [token.strip() for token in tokens if token.strip()]

        # Process the tokens to handle logical operations
        def process_tokens(tokens):
            # Stack for numbers and operators
            num_stack = []
            op_stack = []

            def apply_operator():
                op = op_stack.pop()
                if op == "NOT":
                    num = num_stack.pop()
                    num_stack.append(logical_ops[op](num))
                else:
                    num2 = num_stack.pop()
                    num1 = num_stack.pop()
                    num_stack.append(logical_ops[op](num1, num2))

            i = 0
            while i < len(tokens):
                token = tokens[i]
                if token in logical_ops:
                    if token == "NOT":
                        op_stack.append(token)
                    else:
                        while (
                            op_stack
                            and op_stack[-1] in logical_ops
                            and logical_ops[op_stack[-1]]
                            in [
                                logical_ops["AND"],
                                logical_ops["OR"],
                                logical_ops["XOR"],
                            ]
                        ):
                            apply_operator()
                        op_stack.append(token)
                else:
                    num_stack.append(int(token))
                i += 1

            while op_stack:
                apply_operator()

            return num_stack[0]

        result = process_tokens(tokens)

        # Convert the result back to binary and remove unnecessary padding
        return dec_to_bin(result)

    def abs_binary(self, binary_str):
        """
        Return the absolute value of a binary number given as a string.

        Parameters:
        binary_str (str): The binary string representing the number.

        Returns:
        str: The absolute value of the binary number in binary format.
        """

        def binary_to_decimal(binary_str):
            """Convert a binary string to a decimal float."""
            if "." in binary_str:
                int_part, frac_part = binary_str.split(".")
                int_value = int(int_part, 2)
                frac_value = sum(int(bit) * 2**-i for i, bit in enumerate(frac_part, 1))
                return int_value + frac_value
            else:
                return int(binary_str, 2)

        def decimal_to_binary(decimal_num):
            """Convert a decimal number to a binary string."""
            if decimal_num == 0:
                return "0.0"

            int_part = int(decimal_num)
            frac_part = decimal_num - int_part

            int_bin = bin(int_part).lstrip("0b") + "."

            frac_bin = ""
            while frac_part:
                frac_part *= 2
                bit = int(frac_part)
                frac_part -= bit
                frac_bin += str(bit)
                if (
                    len(frac_bin) > 8
                ):  # limiting the length of the fractional part to 8 digits
                    break

            return int_bin + frac_bin if frac_bin else int_bin.rstrip(".")

        # Remove the negative sign if it exists
        if binary_str.startswith("-"):
            binary_str = binary_str[1:]

        # Convert binary string to decimal
        decimal_value = binary_to_decimal(binary_str)

        # Get the absolute value
        abs_value = abs(decimal_value)

        # Convert the absolute decimal value back to a binary string
        return decimal_to_binary(abs_value)

    def shift_binary_custom(self, direction, shift_amount_bin, number):
        """
        Shifts a binary number to the left or right by a specified amount given in binary.

        Parameters:
        direction (str): '<<' for left shift, '>>' for right shift.
        shift_amount_bin (str): The number of positions to shift as a binary string.
        number (str): The binary number to shift as a string.

        Returns:
        str: The shifted binary number as a string.
        """
        # Convert binary strings to integers
        shift_amount = int(shift_amount_bin, 2)
        number_int = int(number, 2)

        # Perform the shift operation
        if direction == "<<":
            shifted_number = number_int << shift_amount
        elif direction == ">>":
            shifted_number = number_int >> shift_amount
        else:
            raise ValueError(
                "Invalid direction. Use '<<' for left shift or '>>' for right shift."
            )

        # Convert the shifted number back to binary string
        shifted_binary = bin(shifted_number)[2:]  # Remove the '0b' prefix
        return shifted_binary

    def evaluate_hex_expression(self, expression):
        # Regular expression to find hexadecimal numbers (e.g., A, FF)
        hex_pattern = re.compile(r"\b[0-9a-fA-F]+\b")

        # Function to convert hexadecimal to decimal
        def hex_to_dec(match):
            return str(int(match.group(), 16))

        # Replace all hexadecimal numbers in the expression with their decimal equivalents
        decimal_expression = hex_pattern.sub(hex_to_dec, expression)

        try:
            # Evaluate the decimal expression
            result = eval(decimal_expression)
        except Exception as e:
            return f"Error evaluating expression: {e}"

        if isinstance(result, int):
            # Handle negative results by converting to two's complement if necessary
            if result < 0:
                # Assume a fixed 64-bit representation for all negative numbers
                bits = 64

                # Convert to two's complement form
                result = (1 << bits) + result
                hex_result = hex(result).upper()[2:]
            else:
                # Convert the integer result back to hexadecimal
                hex_result = hex(result).upper()[2:]
        elif isinstance(result, float):
            # Handle float result
            # Extract the integer and fractional parts
            integer_part = int(result)
            fractional_part = result - integer_part

            # Convert the integer part to hexadecimal
            hex_integer_part = hex(integer_part).upper()[2:]

            # Convert the fractional part to hexadecimal
            hex_fractional_part = []
            while fractional_part != 0:
                fractional_part *= 16
                hex_digit = int(fractional_part)
                hex_fractional_part.append(hex(hex_digit).upper()[2:])
                fractional_part -= hex_digit
                if (
                    len(hex_fractional_part) > 12
                ):  # Limit precision to avoid infinite loops
                    break
            hex_fractional_part = "".join(hex_fractional_part)

            # Combine both parts
            hex_result = f"{hex_integer_part}.{hex_fractional_part}"

        return hex_result

    def hexidecimal_to_hexidecimal_64bit_segments(self, hex_number):
        if not isinstance(hex_number, str):
            return "Error: Input must be a hexadecimal string."

        try:
            number = int(hex_number, 16)
        except ValueError:
            return "Error: Input must be a valid hexadecimal string."

        if number == 0:
            return ["0" * 16]  # Special case for zero, with a single 16-bit segment

        binary_result = bin(number)[2:]  # Get binary representation without '0b' prefix

        # Pad with leading zeros to make it 64 bits
        binary_result = binary_result.zfill(64)

        # Split into 16-bit segments
        segments = [binary_result[i : i + 16] for i in range(0, 64, 16)]

        return segments

    def logical_ops(self, string):
        # Define allowed operators
        allowed_operators = {"XOR", "OR", "AND", "NOT", "^", "|", "&", "~", "(", ")"}

        # Tokenize the string
        tokens = re.findall(r"\b\w+\b|[&|^~()]+", string)

        # Validate tokens
        for token in tokens:
            if token.isdigit():  # Check if the token is a digit (integer)
                continue
            elif (
                token in allowed_operators
            ):  # Check if the token is an allowed operator
                continue
            else:
                raise ValueError(f"Invalid token found: {token}")

        # Replace logical operators with corresponding symbols
        string = (
            string.replace("XOR", "^")
            .replace("OR", "|")
            .replace("AND", "&")
            .replace("NOT", "~")
        )

        # Final check to ensure the string contains only integers and allowed operators
        if not re.fullmatch(r"[0-9&|^~() ]+", string):
            return (
                string
                + ": The string contains invalid characters or floating-point numbers."
            )

        return eval(string)

    def bin_to_dec(self, binary_str):
        return int(binary_str, 2)

    def oct_to_dec(self, octal_str):
        return int(octal_str, 8)

    def hex_to_dec(self, hex_str):
        return int(hex_str, 16)

    def dec_to_bin(self, decimal_float):
        integer_part = int(decimal_float)
        fractional_part = decimal_float - integer_part
        integer_str = bin(integer_part)[2:]

        fractional_str = ""
        while fractional_part > 0 and len(fractional_str) < 10:
            fractional_part *= 2
            bit = int(fractional_part)
            fractional_str += str(bit)
            fractional_part -= bit

        return integer_str + ("." + fractional_str if fractional_str else "")

    def eval_expression(self, expression, mode):
        if mode == "binary":
            expression = re.sub(
                r"(\b[01]+)", lambda x: str(self.bin_to_dec(x.group(1))), expression
            )

        # Replace common operators for Python eval
        expression = expression.replace("×", "*").replace("÷", "/")

        # Evaluate the expression in decimal
        result = eval(expression)
        return result

    def sqrt_func(self, input_str, mode):
        input_str = input_str.strip().upper()

        # Handle the SQRT operation within the expression
        input_str = re.sub(
            r"SQRT\((.*?)\)",
            lambda m: str(math.sqrt(self.eval_expression(m.group(1), mode))),
            input_str,
        )
        input_str = re.sub(
            r"SQRT([0-9A-Fa-f]+)",
            lambda m: str(math.sqrt(self.eval_expression(m.group(1), mode))),
            input_str,
        )

        # Evaluate the final expression
        decimal_value = self.eval_expression(input_str, mode)

        if decimal_value.is_integer():
            decimal_value = int(decimal_value)

        # Convert back to the original mode
        if mode == "binary":
            result = self.dec_to_bin(decimal_value)
        elif mode == "decimal":
            result = decimal_value

        return result

    def update_operations_display(self):
        self.operations_list.clear()
        self.operations_list.addItems(self.operations)
        self.operations_list.scrollToBottom()

    def update_operations_display2(self):
        self.operations_list2.clear()
        self.operations_list2.addItems(self.operations2)
        self.operations_list2.scrollToBottom()

    def on_item_clicked(self, item):
        self.Result.setText("")
        item_text = item.text()
        self.Result.setText(item_text)  # Use the full item text directly

    def on_item_clicked2(self, item):
        self.Result.setText("")
        item_text = item.text()
        self.Result.setText(item_text)

    def retranslateUi(self, Programmer_calc):
        _translate = QtCore.QCoreApplication.translate
        Programmer_calc.setWindowTitle(
            _translate("Programmer_calc", "Programozói számológép")
        )
        self.Result.setText(_translate("Programmer_calc", ""))
        self.n8_63.setText(_translate("Programmer_calc", ""))
        self.h2_47.setText(_translate("Programmer_calc", ""))
        self.t6_31.setText(_translate("Programmer_calc", ""))
        self.nulla_15.setText(_translate("Programmer_calc", ""))
        self.comboBox_3.setItemText(0, _translate("Programmer_calc", "Decimális"))
        self.comboBox_3.setItemText(1, _translate("Programmer_calc", "Hexadecimális"))
        self.comboBox_3.setItemText(2, _translate("Programmer_calc", "Bináris"))
        self.comboBox_3.setItemText(3, _translate("Programmer_calc", "Oktális"))
        self.label_2.setText(_translate("Programmer_calc", ""))
        self.bel_zj.setText(_translate("Programmer_calc", "("))
        self.eight.setText(_translate("Programmer_calc", "8"))
        self.back.setText(_translate("Programmer_calc", "Vissza"))
        self.D_hex.setText(_translate("Programmer_calc", "D"))
        self.C_hex.setText(_translate("Programmer_calc", "C"))
        self.three.setText(_translate("Programmer_calc", "3"))
        self.minus.setText(_translate("Programmer_calc", "-"))
        self.dot.setText(_translate("Programmer_calc", "."))
        self.B_hex.setText(_translate("Programmer_calc", "B"))
        self.clear.setText(_translate("Programmer_calc", "DEL"))
        self.four.setText(_translate("Programmer_calc", "4"))
        self.jobb_zj.setText(_translate("Programmer_calc", ")"))
        self.one.setText(_translate("Programmer_calc", "1"))
        self.nine.setText(_translate("Programmer_calc", "9"))
        self.mod.setText(_translate("Programmer_calc", "mod"))
        self.A_hex.setText(_translate("Programmer_calc", "A"))
        self.zero.setText(_translate("Programmer_calc", "0"))
        self.two.setText(_translate("Programmer_calc", "2"))
        self.six.setText(_translate("Programmer_calc", "6"))
        self.F_hex.setText(_translate("Programmer_calc", "F"))
        self.plusz.setText(_translate("Programmer_calc", "+"))
        self.seven.setText(_translate("Programmer_calc", "7"))
        self.equal.setText(_translate("Programmer_calc", "="))
        self.five.setText(_translate("Programmer_calc", "5"))
        self.divide.setText(_translate("Programmer_calc", "/"))
        self.szorzas.setText(_translate("Programmer_calc", "x"))
        self.sqrt.setText(_translate("Programmer_calc", "sqrt"))
        self.E_hex.setText(_translate("Programmer_calc", "E"))
        self.pi.setText(_translate("Programmer_calc", "pi"))
        self.fakt.setText(_translate("Programmer_calc", "x!"))
        self.XOR.setText(_translate("Programmer_calc", "XOR"))
        self.abs.setText(_translate("Programmer_calc", "|x|"))
        self.log.setText(_translate("Programmer_calc", "log"))
        self.x_xx_y.setText(_translate("Programmer_calc", "x^y"))
        self.ones.setText(_translate("Programmer_calc", "ones"))
        self.int_2.setText(_translate("Programmer_calc", "int"))
        self.x_xx_1.setText(_translate("Programmer_calc", "x^-1"))
        self.twos.setText(_translate("Programmer_calc", "twos"))
        self.AND.setText(_translate("Programmer_calc", "AND"))
        self.log2.setText(_translate("Programmer_calc", "log2"))
        self.OR.setText(_translate("Programmer_calc", "OR"))
        self.shift_left.setText(_translate("Programmer_calc", "<<"))
        self.shift_right.setText(_translate("Programmer_calc", ">>"))
        self.aaaa.setText(_translate("Programmer_calc", "á"))
        self.fact.setText(_translate("Programmer_calc", "fact"))


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    Ui_Programmer_calculator = QtWidgets.QMainWindow()
    ui = Ui_Programmer_calculator()
    ui.setupUi(Ui_Programmer_calculator)
    Ui_Programmer_calculator.show()
    sys.exit(app.exec_())
